# DBObject

* DBObject的主要思路在于, 模型的构造, 在QT的属性化的时候, 我们手动添加关于类的属性信息, 然后就拥有了get, set以及propertyMap等方法, 但是OC的runtimeCode本身提供了这些, 所以我们可以通过objec_copyPropertyList等函数, 拿到一个类的属性列表信息, 甚至可以拿到从自己到根NSObject类的所有的属性信息.

* 在拿到这些属性信息之后, 通过getvalue方法, 从背拷贝对象取值, 然后赋值到拷贝对象里, 这样就完成了模型的构建的工作. 复杂的地方, 在于容器类属性的构建.

* 因为通过copyPropertyList拿到的, 是@encoding之后的C语言字符串代表的属性化的描述, 所以代码里有很多关于这方面的判断, 例如 `OC strcmp(raw_type, @encode(unsigned long)) == 0` , 然后根据这个信息去构建相应的对象(因为OC的KVC-SET方法是要传入一个对象的). 麻烦的地方在于, 对象元素的赋值过程和结构体的赋值过程.

* 结构体的赋值过程,  是判断属性描述中结构体名, 构建一个NSValue包装

* 对象的类型比较麻烦. 首先, 字典的话, 没有进行内部的类型处理. 数组的话, 各个数据子类可以提供一个propertyGenericMap的方法, 提供每个数字里面应该提供什么类型的变量, 那么在构建过程中会根据提供的类型, 构建一个新的对象, 然后进行赋值操作. 如果不是集合类, 那么就直接赋值了被拷贝类的value到这个属性上, 但是其实有个问题, 就是如果两个属性类型不一致怎么办. 例如数据类owner是Person类, 而被拷贝类owner是一个字典, 这个时候, 也可以在propertyGenericMap中指明@{@"owner", @"Person"}, 那么会进行一个Person的构建和值拷贝的工作, 构造出一个Person来, 然后赋值到owner的属性上.

* propertyMap是提供给, 被拷贝类的属性名和数据类属性名不一致的情况. 提供一个映射.

* dictionary是一个将数据类所有属性, 变成一个字典值的方法.

* 需要注意, propertyGenericMap这个方法, 很重要. 如果没有提供映射关系, 在被拷贝类和数据类属性类型不一致的情况下, 最终结果是数据类的该属性, 是一个被拷贝类那个属性的值, 也就是类型错误了.