# Introduction to Computer network and IP address

## 当输入www.google.com 的时候,会发生什么  
如果是第一次访问,计算机会请求dns服务器,将www.google.com 转换成为ip地址,然后计算机会将这个映射缓存.如果下一次输入一个新的网址,或者google的缓存过期了,这个时候计算机会再次访问dns服务器,否则就读取缓存中的ip地址.  
然后计算机就通过这个ip地址以及port地址,去请求资源,这个过程中,有着请求的路由过程.通过ip地址,找到服务器的地址,通过port地址,找到请求的程序.然后服务器response,回应数据包在经过一系列的寻址最后返回到客户端.  

## ip地址
ip分为两部分,network号以及host号.  
network就是网络号,host号就是这个网络的主机号.  
iPV4是占据4个字节的ip数据,根据最原始的定义,前面的8位是network号,后面的24位是host号,但是这样有个问题就是network号太少而host号过于多.于是就有了ip分类的概念.  

## ip分类:分类网络
class a,b,c,d,e  
总的来说,就是将ip的前几位当做是标志位,通过标志位对ip进行分类.不同的分类,networkId占据的位数不一样.a类最少,但是host的个数超级大.c类网络为很多,但是host的个数很少.具体的细节在下面.

``` 

Class	前缀位	网络地址位数	剩余的位数	网络数	每个网络的主机数
A类地址	0	8	24	128	16,777,214
B类地址	10	16	16	16,384	65,534
C类地址	110	24	8	2,097,152	254
D类地址（群播）	1110	未定义	未定义	未定义	未定义
E类地址（保留）	1111	未定义	未定义	未定义	未定义
``` 

## UTF-8
上面的和UTF-8的模式很像,这里复习一下UTF-8的规则.  

```
对于UTF-8编码中的任意字节B，如果B的第一位为0，则B独立的表示一个字符(ASCII码)；
如果B的第一位为1，第二位为0，则B为一个多字节字符中的一个字节(非ASCII字符)；
如果B的前两位为1，第三位为0，则B为两个字节表示的字符中的第一个字节；
如果B的前三位为1，第四位为0，则B为三个字节表示的字符中的第一个字节；
如果B的前四位为1，第五位为0，则B为四个字节表示的字符中的第一个字节； 
```

[阮一峰的字符编码笔记](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)

``` 
UTF-8的编码规则很简单，只有二条：
1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。
2）对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。
```
UTF-8 解决了两个问题:  
1. 英语字符一个字节就可以表示了,如果都用unicode来表示,那么一个英文字符要占据太多的空间了.  
2. 如果判断,这个字符是一个字节还是多个字节.unicode仅仅是规定了每个字符的序列,但是怎么用计算机表示呢.比如三个字节的一个数据,代表的数字是312321,那么这个三个字节的数据,是代表312321的uncidoe代表的字符,还是三个字符呢.需要一种方式来告诉计算机,接下来几个字节是一个字符,按照这个字节数取后面的值就可以了.

* 文本的大小端模式   

>
上一节已经提到，Unicode码可以采用UCS-2格式直接存储。以汉字"严"为例，Unicode码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，就是Big endian方式；25在前，4E在后，就是Little endian方式。
这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。
因此，第一个字节在前，就是"大头方式"（Big endian），第二个字节在前就是"小头方式"（Little endian）。
那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？
Unicode规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做"零宽度非换行空格"（ZERO WIDTH NO-BREAK SPACE），用FEFF表示。这正好是两个字节，而且FF比FE大1。
如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。

* 计算机的大小端模式  

> 大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。
小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。  
> 为什么会有大小端模式之分呢？这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于 8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于 大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以随时在程序中(在ARM Cortex 系列使用REV、REV16、REVSH指令[1]  )进行大小端的切换。

	