面向对象的语言,都有一个标志,那就是都有类的概念,而通过类可以创建任意多个具有相同属性和方法的对象.
js中把对象定义为: 无序属性的集合,属性可以是基本值,对象,或者函数.严格来说,就是说对象是一组没有特定顺序的值而已.对象的每个属性和方法都有一个名字,而每个名字都映射到了一个值,因为这样,我们可以想象js中的对象,无非就是一组名值对,其中,值可以是数据或者是函数.

js中有两种属性,数据属性和访问器属性.
1. 数据属性
数据属性包含一个数据值的位置.在这个位置可以读取和写入值.
[[configurable]] 可不可以重新定义 bool, [[enumerable]] 可不可以for-in,bool, [[writable]] 可不可写bool, [[value]] value
如果想要改,就必须要用Object.defineProperty方法.
Object.defineProeprty(person, "name", {
    writable: false,
    value: "Nicholas"
});
一般来说,在业务层面不应该设计到修改属性的属性这种功能.
2. 访问器属性
[[configurable]] 可不可以重新定义 bool, [[enumerable]] 可不可以for-in,bool, [[get]] get 方法, [[set]] set 方法.
访问器属性不能直接定义,而是用defineProperty来进行定义.
var book = {
    _year = 2004, // _开头,表示只能通过对象方法访问的属性
    edition: 1
}
Object.defineProperty(book, "year", {
    get: function() {
        return this._year;
    }
    set: function(newValue) {
        // 附加操作
        this._year = newValue;
        // 附加操作.使用访问器属性的常见方式,就是在属性值的改变会引起其他的变化.
    }
})

Object.defineProperties 定义多个属性的特性. 
Object.getOwnPropertyDescriptor()方法,取得给定属性的描述符.

## 创建对象
之前创建对象,无论是通过字面量的方式,还是通过var obj = Object(), obj.name = "jansti"... 这种方式,都有大量的代码,而之前的变成语言,则是将一个类型的属性,方法写在一个类型的内部,然后定义出来的对象,就自动拥有这些属性方法了.js里也应该这样.

### 工厂模式
funcation createPerson(name, age) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.sayName = function() {};
    return o;
}
这种方法,虽然解决了创建相似问题的问题,但是没有解决对象识别的问题.

### 构造函数模式
funcation Person(name, age) {
    this.name = name;
    this.age = age;
    this.sayName = function() {};
}
这种方法
1. 没有显示的创建对象
2. 直接将属性和方法付给了this对象
3. 没有return语句.
4. 函数名第一个是大写字母.当然,这是程序员为了维护和其他语言类大写首字母的规则.
要用Person创建新的实例,必须要用new操作符.用这种方法:
1. 会创建一个新的对象.--var o = new Object();
2. 将构造函数的作用域赋值给这个新的对象,就是this就是这个新对象了.--Person.bind(o)
3. 执行构造函数里面的代码.-- 给this,也就是0赋值
4. 返回新对象. -- return o
我们看到,其实还是工厂方法里的那些代码,但是js里面会自动生成一些代码.保证返回一个新的实例对象.
而用构造函数创建的对象,person1.constructor == Person true.这样,对象的constructor属性,指向了Person函数. 用自定义的构造函数意味着,可以将它的实例标示为一种特定的类型,而这正是构造函数模式胜过工厂模式的地方.

构造函数模式的问题.
构造函数的问题在于,每个函数都要在每个实例上重新创建一边.而函数,就是操作,对于一个类型的所有实例都是适用的.现在新建一个实例,就要生成一个方法,这样100个实例就产生了100个同样功能但是又独立占据空间的函数.那么可以怎么办呢,可以在全局作用域创建一个函数,然后在构造函数内部让所有的对象保持这个函数的引用.但是这样,又让程序的封装性遭到了破坏.于是引出了下一个模式. 

## 原型模式.
我们创建的每一个函数,都有一个原型属性,这个属性是一个指针,指向一个对象,而这个对象的用途就是包含可以由特定类型的所有实例共享的属性和方法.可以理解为,prototype就是通过构造函数创建的对象的实例的原型对象.可以让所有的对象实例,共享原型的属性和方法.
function Person() {

}

Person.prototype.name = "jansti";
Person.prototype.age = 29;
Person.prototype.sayHi = function() {};

以上的两个属性和一个方法,是所有的实例共有的.也就是所有的实例,都有name,age,sayhi,但是,都是一份数据,改一个,所有的实例的这些属性都会更改.为什么这样.

原型对象是什么???
只要创建一个新函数,就会创建一个prototype独享,而默认下,原型对象会有一个constructor属性,指向这个原型对象所在的函数的指针.也就是Person.prototype.constructor 指向了Person.
在创建了函数之后,这个函数的原型对象里,只有constructor这一个属性.其他的则是从Object里派生出来的.而当创建一个实例之后,实例的内部会有一个指针,指向构造函数的原型对象[[Prototype]]. 重要的是,这个链接存在于实例和构造函数的原型对象之间,不是实例和构造函数之间的.
也就是说,实例是和原型对象之间有个关系,但是其实它们和构造函数之间没有直接的关系.而实例可以调用原型对象里面的属性.
isPrototypeOf()方法,来确定对象之间的关系.如果,对象的[[Prototype]]指向了这个方法的调用者,就返回true
及 Person.prototype.isPrototypeOf(personInstance)  返回true.
js 5中,Object.getPrototypeOf() 方法,可以返回,一个实例中的原型.

每当代码想要读取某个属性的时候,都会执行一次搜索,目标是具有给定名字的属性,首先,搜索的是对象实例本身,没有的话,就搜索实例的原型对象(通过[[ProtoType]]).这就是多个对象可以通过原型共享属性和方法的原理. 
但是,实例是没有办法重新原型中的值的,如果我们在实例中添加了一个属性,和原型中重名,根据上面的原则,修改这个属性,也是修改实例中的属性,这里,重名的属性屏蔽了原型的属性.

使用hasOwnProperty() 方法, 可以检测一个属性是存在于实例中,还是存在原型中.这个方法,只有属性在实例的时候,才会返回true.

in操作符.
单独谁用,会在对象能够访问给定的属性的时候返回true.无论是在实例中还是在原型中.
forin则会遍历所有对象能够访问的属性,无论是在实例中,还是在原型中.
而Object.keys可以返回实例上的可枚举属性,不包含原型中的.


### 更简单的原型模式
function Person() {

}
Person.prototype = {
    name: "jansti";
}
就是同过用字面量的方式,设置prototype的值.但是,这样constructor就不在指向Person了.因为这样其实是覆盖了原来的原型对象了,如果constructor很重要,可以在字面量里面特意的设置回去.

原生的类型,也是在原型上定义了很多的方法,然后这些实例就可以使用这些方法了.我们也可以给原型增加方法,但是不建议这样做.

## 原型对象的问题.
这种模式最大的问题,在于属性也被所有的实例共享了,而共享仅仅是对于函数才合适的.
## 使用构造函数加原型的模式
构造函数模式,用于定义实例属性,而原型模式,则是用于定义方法和共享的属性.
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.friends = ["a", "b"];
}
Person.prototype = {
    constructor: Person,
    sayName: function() {
        alert(this.name);
    }
}


#继承
## 原型链
利用原型,让一个引用类型继承另外一个引用类型的属性和方法.我们如果让原型对象,等于另外一个类型的实例,此时的原型对象将包含一个指向另一个原型的指针.这样下次,层层递进,就构成了实例和原型的链条.这样实现的本质就是,重写原型对象,代替为一个新类型的实例.

## 借用构造函数
原型链的问题在于,父类的属性都变成了子类的原型里的属性了,也就是父类的属性本来是各个实例单独有的,现在成为子类里共有的了.解决这个问题,可以通过在子类中调用父类的构造函数,显示的将父类中定义的属性在子类中重新定义一次.




