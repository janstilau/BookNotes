js变量的松散类型本质,决定了它只是在特定时间里面用于保存特定值的一个名字而已.


# 基本类型和引用类型
基本类型的值指的是简单的数据段,引用类型值是那些可能由多个值构成的对象.
undefined, null, boolean, number 和 string 都是基本类型的值.可以直接操作保存在变量中的实际的值.
引用类型的值是保存在内存中的对象.js中不允许直接访问内存中的位置,不能直接操作对象的内存空间.所以,在操作对象的时候,实际上是操作对象的引用而不是实际的对象.值得注意的是,js中字符串是值类型的.

1. 动态添加属性方法
对于引用类型的值,我们可以给他的添加属性和方法.但是不能给值类型添加属性和方法.
2. 复制
复制基本类型的值,是创建新的空间,复制数据过去.
而引用类型,就是一个复制一个地址过去.
3. 传递参数
函数的参数都是值传递的.参数,就是函数内的一个局部变量而已.参数传递传入基本类型,就是复制基本类型的值到参数上,传递引用类型,就是传递引用类型的地址到参数上.所以,在函数内部,操作引用类型的话,其实是和实参一样的一块地址空间.
4. 检测类型
instanceof操作符.
如果变量是给定的引用类型,那么就返回true.
所有的引用类型都是Object的实例,所以所有的引用对象的 instanceof Object 都是true.


# 执行环境和作用域.
执行环境,都有着与之关联的变量对象,环境中定义的所有变量和函数都保存在这个对象内部.
全局环境是最外围的一个执行环境,web中,这个全局执行环境是window对象,因此所有的全局变量和函数都是window对象的属性和方法.某个执行环境的所有代码执行完之后,这个环境就被销毁,保存在其中的所有变量和函数的定义也随之销毁了.
每个函数,都有自己的执行环境,当执行流进入一个函数的时候,函数的环境就被推入到了一个环境栈中,当函数执行之后,这个栈就将这个环境弹出,并把控制权交给之前的执行环境.
总之,每个环境中的作用域链,都是自己的变量对象开始,依次往上添加,一直到全局环境的变量对象.

执行环境的类型总共就两种,全局的和函数的.

没有块级作用域.别的语言,{}之间定义的变量,会在}之后被销毁.但是,js中,{}之间的变量还是被保留下来了.那个变量被注册到当前的执行环境之中了,还是可以被找到的.
使用var声明的变量,会自动添加到最近的执行环境之中,在函数的内部,最近的执行环境就是函数的局部环境.如果在初始化的时候,没有用var进行声明,就被添加到全局环境中去.

环境中,当碰到一个变量或者函数的时候,会有一个搜索过程,来确定这个到底是代表什么.搜索的开始是自己所在环境的变量对象,一直到全局环境的变量对象.来查看各个变量对象里面,是不是拥有正在搜索的标识符.这样,就能确定是哪个环境定义的变量了.



## 垃圾回收
js中,最常用的就是标记清楚,当变量进入环境的时候,这个变量就被标记成为了进入环境,(例如,声明一个变量),逻辑上讲,不能释放进入环境的变量占用的内存,因为只要执行流进入了环境,就有可能用到它们.当变量离开环境的时候,就将其标记成为'离开环境'.
另外的一个策略就是引用计数.和oc里面一样.但是,由于IE中有一部分不是原生的js对象,比如bom,dom中的对象就是引用计数的.所以,依然会有引用计数的问题,就是循环引用.这个时候,最好的策略就是在使用完之后,主动地设置某某引用的值为null,让这个循环主动断掉.

## 总结
基本数据类型: undefined, null, boolean, number 和 string
基本数据类型是内存中占据固定大小,引用是指针,真正的对象空间在另外的地方(堆中???)



