# 对象
对象（object）是JavaScript的核心概念，也是最重要的数据类型。JavaScript的所有数据都可以被视为对象。
简单说，所谓对象，就是一种无序的数据集合，由若干个“键值对”（key-value）构成。
var o = {
    p: 'Hello world'
};
对象的每一个“键名”又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。
对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。
属性可以动态创建，不必在对象声明时就指定。这样就很方便了, 之前的语言里面, 所有的类都要预先设计, 而在JS中, 对象就是一个键值对应的盒子而已. 

对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？
{ foo: 123 }
JavaScript引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含foo属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签foo，指向表达式123。
为了避免这种歧义，JavaScript规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。

## 属性的操作
读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。
var o = {
  p: 'Hello World'
};
o.p // "Hello World"
o['p'] // "Hello World"
如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。但是，数字键可以不加引号，因为会被当作字符串处理。
方括号运算符内部可以使用表达式。

## 检查变量是否声明
如果读取一个不存在的键，会返回undefined，而不是报错。可以利用这一点，来检查一个全局变量是否被声明
// 检查a变量是否被声明
if (a) {...} // 报错
if (window.a) {...} // 不报错
if (window['a']) {...} // 不报错
上面的后二种写法之所以不报错，是因为在浏览器环境，所有全局变量都是window对象的属性。window.a的含义就是读取window对象的a属性，如果该属性不存在，就返回undefined，并不会报错。
需要注意的是，后二种写法有漏洞，如果a属性是一个空字符串（或其他对应的布尔值为false的情况），则无法起到检查变量是否声明的作用。正确的做法是可以采用下面的写法。if( 'a' in window) { ...} 

## 属性的赋值
点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值
JavaScript允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。

## 查看所有的属性
查看一个对象本身的所有属性，可以使用Object.keys方法。返回一个数组, 里面包含着属性的字符串表示. 
这个keys返回的数组中, 只有对象自己包含的属性, 没有继承过来的属性. 

## delete命令
delete命令用于删除对象的属性，删除成功后返回true。
var o = {p: 1};
delete o.p // true
注意，删除一个不存在的属性，delete不报错，而且返回true。因此，不能根据delete命令的结果，认定某个属性是存在的，只能保证读取这个属性肯定得到undefined。delete命令会返回false，那就是该属性存在，且不得删除。
var o = Object.defineProperty({}, 'p', {
  value: 123,
  configurable: false
});
o.p // 123
delete o.p // false
需要注意的是，delete命令只能删除对象本身的属性，无法删除继承的属性. 但是, delete的返回值还是true. 
delete命令不能删除var命令声明的变量，只能用来删除属性。

## in运算符
in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。
in运算符的一个问题是，它不能识别对象继承的属性。就是, 如果a属性是继承下来的, 那么a in value 就会返回true. 
如果想要获取对象独有的属性, 可以用hasOwnProperty()

## for...in循环
用来遍历一个对象的全部属性. 
下面是一个使用for...in循环，提取对象属性的例子。
var obj = {
  x: 1,
  y: 2
};
var props = [];
var i = 0;
for (props[i++] in obj);
props // ['x', 'y']
它为什么这么写呢, for...in应该是在对象的键数组中, 分别取值, 然后复制到for...in的左边, 这其中其实是有个赋值操作的. 
它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性
它不仅遍历对象自身的属性，还遍历继承的属性。如果只想遍历对象本身的属性，可以使用hasOwnProperty方法，在循环内部判断一下是不是自身的属性。
都是只想遍历对象自身的属性，所以不推荐使用for...in循环。

## with语句
with语句的格式如下：
with (object) {
  statements;
}
它的作用是操作同一个对象的多个属性时，提供一些书写的方便。
with (o) {
  p1 = 1;
  p2 = 2;
}
// 等同于
o.p1 = 1;
o.p2 = 2;
with区块内部的变量，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。这是因为with区块没有改变作用域，它的内部依然是当前作用域。
var o = {};
with (o) {
  x = "abc";
}
o.x // undefined
x // "abc"
上面代码中，对象o没有属性x，所以with区块内部对x的操作，等于创造了一个全局变量x。正确的写法应该是，先定义对象o的属性x，然后在with区块内操作它。
这是with语句的一个很大的弊病，就是绑定对象不明确。因此，建议不要使用with语句，可以考虑用一个临时变量代替with。



