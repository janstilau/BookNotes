# 运算符

## 加法运算符
JS中, +可以完成两种运算, 1是算术的加法, 2是字符串的拼接.   
运算规则如下:
如果运算子是对象，先自动转成原始类型的值（即先执行该对象的valueOf方法，如果结果还不是原始类型的值，再执行toString方法；如果对象是Date实例，则先执行toString方法）。
两个运算子都是原始类型的值以后，只要有一个运算子是字符串，则两个运算子都转为字符串，执行字符串连接运算。
否则，两个运算子都转为数值，执行加法运算。
'1' + {foo: 'bar'} // "1[object Object]"
'1' + 1 // "11"
'1' + true // "1true"
'1' + [1] // "11"
这种由于参数不同，而改变自身行为的现象，叫做“重载”（overload）。由于加法运算符是运行时决定到底执行那种运算，使用的时候必须很小心。
x + '' 这样写, 可以用来将一个值转为字符串。
加法运算符一定有左右两个运算子，如果只有右边一个运算子，就是另一个运算符，叫做“数值运算符”。
加法运算符以外的其他算术运算符（比如减法、除法和乘法），都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。

## 算术运算符

加法运算符（Addition）：x + y
减法运算符（Subtraction）： x - y
乘法运算符（Multiplication）： x * y
除法运算符（Division）：x / y
余数运算符（Remainder）：x % y
自增运算符（Increment）：++x 或者 x++
自减运算符（Decrement）：--x 或者 x--
数值运算符（Convert to number）： +x
负数值运算符（Negate）：-x

### 余数运算符
余数运算符（%）返回前一个运算子被后一个运算子除，所得的余数
需要注意的是，运算结果的正负号由第一个运算子的正负号决定。
为了得到正确的负数的余数值，需要先使用绝对值函数。

### 自增和自减运算符
自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量。

### 数值运算符（+)
同样是使用加号, 但是它是一个一元运算符
它的作用在于, 可以将任何值转化成为数值.这和number函数的作用相同. 
+true // 1
+[] // 0
+{} // NaN

负数值运算符（-），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。连用两个负数值运算符，等同于数值运算符。

### 赋值运算符
### 比较运算符
比较运算符用于比较两个值，然后返回一个布尔值，表示是否满足比较条件.比较运算符可以比较各种类型的值，不仅仅是数值。
== 相等
=== 严格相等
!= 不相等
!== 严格不相等
< 小于
<= 小于或等于
> 大于
>= 大于或等于

如果两个运算子都是字符串，则按照字典顺序比较（实际上是比较 Unicode 码点）。
否则，将两个运算子都转成数值，再进行比较（等同于先调用Number函数）。

#### 字符串的比较
字符串按照字典顺序进行比较. JavaScript 引擎内部首先比较首字符的 Unicode 码点，如果相等，再比较第二个字符的 Unicode 码点，以此类推。
#### 非字符串的比较
两个原始类型的值的比较，除了相等运算符（==）和严格相等运算符（===），其他比较运算符都是先转成数值再比较。
这里有一个特殊情况，即任何值（包括NaN本身）与NaN比较，返回的都是false。
如果运算子是对象，会转为原始类型的值，再进行比较。
对象转换成原始类型的值，算法是先调用valueOf方法；如果返回的还是对象，再接着调用toString方法，
var x = [2];
x > '11' // true  因为'2' > '11'


### 严格相等运算符
简单说，它们的区别是相等运算符（==）比较两个值是否相等，严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转化成同一个类型，再用严格相等运算符进行比较。

严格相等运算符的算法如下。
（1）不同类型的值
如果两个值的类型不同，直接返回false。
（2）同一类的原始类型值
同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。
（3）同一类的复合类型值
两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。
{} === {} // false
[] === [] // false
(function (){} === function (){}) // false
上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。原因是对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是false。
对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。

 (4) undefined和null与自身严格相等。
（5）严格不相等运算符
严格相等运算符有一个对应的“严格不相等运算符”（!==），两者的运算结果正好相反

### 相等运算符
相等运算符比较相同类型的数据时，与严格相等运算符完全一样。
比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。类型转换规则如下。
（1）原始类型的值
原始类型的数据会转换成数值类型再进行比较
（2）对象与原始类型值比较
对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。
（3）undefined 和 null
undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。
绝大多数情况下，对象与undefined和null比较，都返回false。只有在对象转为原始值得到undefined时，才会返回true，这种情况是非常罕见的。
（4）相等运算符的缺点
相等运算符隐藏的类型转换，会带来一些违反直觉的结果。
'' == '0'           // false
0 == ''             // true
0 == '0'            // true

2 == true           // false
2 == false          // false

false == 'false'    // false
false == '0'        // true

false == undefined  // false
false == null       // false
null == undefined   // true

' \t\r\n ' == 0     // true



..... 中间大部分没有看, 用的时候再看

## 其他运算符
### void运算符
void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。
void(0) // undefined
这个运算符主要是用于书签工具（bookmarklet），以及用于在超级链接中插入代码，目的是返回undefined可以防止网页跳转。
<a href="javascript:void window.open('http://example.com/')">
  点击打开新窗口
</a>
上面代码用于在网页中创建一个链接，点击后会打开一个新窗口。如果没有void，点击后就会在当前窗口打开链接。
