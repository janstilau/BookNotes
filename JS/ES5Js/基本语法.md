# 基本语法

## 语句
JavaScript程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。
语句（statement）是为了完成某种任务而进行的操作  
var a = 1 + 3
1 + 3叫做表达式（expression），指一个为了得到返回值的计算式。
语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。
语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内
分号前面可以没有任何内容，JavaScript引擎将其视为空语句。
表达式不需要分号结尾。一旦在表达式后面添加分号，则JavaScript引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。

其实不用弄清楚到底语句和表达式的具体区别. 

## 变量
变量是对“值”的引用，使用变量等同于引用一个值。每一个变量都有一个变量名。
var a = 1;
var，是变量声明命令。它表示通知解释引擎，要创建一个变量a。变量的声明和赋值，是分开的两个步骤
如果只是声明变量而没有赋值，则该变量的值是undefined。undefined是一个JavaScript关键字，表示“无定义”。
可以按照C语言理解, 声明时开辟空间, 赋值是给空间填值. 没有赋值的变量在C中是随机值, JS中是undefined. 

### 变量提升
JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。  

### 标识符
标识符（identifier）是用来***识别具体对象***的一个名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript语言的标识符对大小写敏感，所以a和A是两个不同的标识符。

### 注释
### 区块
大括号, 将多个相关的语句组合在一起, 组成了区块. 
JS中的区块不能构成单独的作用域, 也就是说, 区块中的变量和区块外的变量, 属于同一作用域. 所以单独使用区块意义不大, 一般和for, if, while, function 一起使用.
不过ES6中, let可以在区块里面也有作用域的概念了. 

### 条件语句
#### if else
else代码块总是跟随离自己最近的那个if语句。
```
var m = 1;
var n = 2;
if (m !== 1)
if (n === 2) console.log('hello');
else console.log('world');
```  
相当于
```
if (m !== 1) {
  if (n === 2) {
    console.log('hello');	
  } else {
    console.log('world');
  }
}
```
但是, 谁会向上面那样写代码.

#### switch case 
switch语句后面的表达式与case语句后面的表示式，在比较运行结果时，采用的是严格相等运算符（===），而不是相等运算符（==），这意味着比较时不会发生类型转换。

### 循环 
while, for, dowhile
### breakcontinue
### label
JavaScript语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。
label: 
    statement
标签通常与break语句和continue语句配合使用，跳出特定的循环
continue语句也可以与标签配合使用。
```
top:
  for (var i = 0; i < 3; i++){
    for (var j = 0; j < 3; j++){
      if (i === 1 && j === 1) break top;
      console.log('i=' + i + ', j=' + j);
    }
  }
```


# 数据类型

数值（number）：整数和小数（比如1和3.14）
字符串（string）：字符组成的文本（比如”Hello World”）
布尔值（boolean）：true（真）和false（假）两个特定值
undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值
null：表示无值，即此处的值就是“无”的状态。
对象（object）：各种值组成的集合
Symbol

通常，我们将数值、字符串、布尔值称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。而将对象称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于undefined和null，一般将它们看成两个特殊值。

对象又可以分成三个子类型。
狭义的对象（object）
数组（array）
函数（function）

狭义的对象和数组是两种不同的数据组合方式，而函数其实是处理数据的方法。JavaScript把函数当成一种数据类型，可以像其他类型的数据一样，进行赋值和传递，这为编程带来了很大的灵活性，体现了JavaScript作为“函数式语言”的本质。
这里需要明确的是，JavaScript的所有数据，都可以视为广义的对象。不仅数组和函数属于对象，就连原始类型的数据（数值、字符串、布尔值）也可以用对象方式调用。为了避免混淆，此后除非特别声明，本教程的”对象“都特指狭义的对象。

## typeof 
JS中有三种方法, 可以确定一个值是什么类型. 
typeof运算符
instanceof运算符
Object.prototype.toString方法

Typeof运算符
1. 原始类型 - 数值、字符串、布尔值分别返回number、string、boolean。
2. 函数 - 函数返回 function
3. undefined - undefined 返回 uneducated
4. 其他 返回 object, array, null 返回 object
这并不是说null就属于对象，本质上null是一个类似于undefined的特殊值。null返回object是历史原因. 

## null和undefined
在bool运算的时候, 都是被转换成为了false. 在==的时候, 返回也是true
目前null和undefined基本是同义的，只有一些细微的差别。
null的特殊之处在于，JavaScript把它包含在对象类型（object）之中. 在转化number的时候, null => 0, undefined => NaN
JavaScript的标识名区分大小写，所以undefined和null不同于Undefined和Null（或者其他仅仅大小写不同的词形），后者只是普通的变量名。

null表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入null，表示未发生错误。
undefined表示“未定义”。
也就是说, null是程序员主动控制的一个值, 某个值, 如果设置成为了null, 就是这个值就是null的含义, 具体这个含义是什么, 在编写代码的时候定义. 但是undefined就是未定义, 可能是逻辑有问题, 也可能是多个参数后的没有传入. undefined就代表未定义, 没有值, 没有值不代表值为空. 

## 布尔值
true false, 布尔值仅仅有这两个值. 
两元逻辑运算符： && (And)，|| (Or)
前置逻辑运算符： ! (Not)
相等运算符：===，!==，==，!=
比较运算符：>，>=，<，<=
如果JavaScript预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。
undefined
null
false
0
NaN
""或''（空字符串）
需要特别注意的是，空数组（[]）和空对象（{}）对应的布尔值，都是true。

# 数值
## 整数和浮点数
JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数。
JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数)
如果指数部分等于或超过最大正值1024，JavaScript 会返回Infinity（关于Infinity的介绍参见下文），这称为“正向溢出”；如果等于或超过最小负值-1023（即非常接近0），JavaScript 会直接把这个数转为0，这称为“负向溢出”。
至于具体的最大值和最小值，JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性表示

## 进制
十进制：没有前导0的数值。
八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。
十六进制：有前缀0x或0X的数值。
二进制：有前缀0b或0B的数值。
通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制。

## 特殊数值
正零和负零都会被当作正常的0。
除以正零得到+Infinity，除以负零得到-Infinity，这两者是不相等的


NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。
需要注意的是，NaN不是一种独立的数据类型，而是一种特殊数值，它的数据类型依然属于Number，使用typeof运算符可以看得很清楚。
NaN不等于任何值，包括它本身。
NaN在布尔运算时被当作false。
NaN与任何数（包括它自己）的运算，得到的都是NaN。
isNaN方法可以用来判断一个值是否为NaN。isNaN只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成NaN，所以最后返回true，这一点要特别引起注意。也就是说，isNaN为true的值，有可能不是NaN，而是一个字符串。对于对象和数组，isNaN也返回true。对于空数组和只有一个数值成员的数组，isNaN返回false。因此，使用isNaN之前，最好判断一下数据类型。 typeof value === 'number' && isNaN(value);判断NaN更可靠的方法是，利用NaN是JavaScript之中唯一不等于自身的值这个特点，进行判断。value !== value; 


Infinity
Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。Infinity有正负之分，Infinity表示正的无穷，-Infinity表示负的无穷。  
由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，JavaScript都不报错，而是返回Infinity，所以单纯的数学运算几乎没有可能抛出错误。
具体Infinity 的计算规则没看, 用到的时候在看. 
isFinite函数返回一个布尔值，检查某个值是不是正常数值，而不是Infinity. 

## 与数值相关的全局方法
### parseInt
parseInt方法用于将字符串转为整数。
如果parseInt的参数不是字符串，则会先转为字符串再转换。
字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。
如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。
parseInt的返回值只有两种可能，不是一个十进制整数，就是NaN。
如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析. 如果字符串以0开头，将其按照10进制解析
parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制。
如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值。如果最高位无法转换，则直接返回NaN。
parseInt('1546', 2) // 1 对于二进制来说, 546都是没有意义的字符. 
上面都可以不看, 有问题再去查
### parseFloat()
parseFloat方法用于将一个字符串转为浮点数。

# 字符串
字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。
单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。
如果要在单引号字符串的内部，使用单引号（或者在双引号字符串的内部，使用双引号），就必须在内部的单引号（或者双引号）前面加上反斜杠，用来转义。
'Did she say \'Hello\'?'
// "Did she say 'Hello'?"
"Did she say \"Hello\"?"
// "Did she say "Hello"?"

字符串默认只能写在一行内，分成多行将会报错。
'a
b
c' // 报错
如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠  . 连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。

##转义 
反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。
\0 null（\u0000）
\b 后退键（\u0008）
\f 换页符（\u000C）
\n 换行符（\u000A）
\r 回车键（\u000D）
\t 制表符（\u0009）
\v 垂直制表符（\u000B）
\' 单引号（\u0027）
\" 双引号（\u0022）
\\ 反斜杠（\u005C）
\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。HHHH对应该字符的Unicode码点，比如\u00A9表示版权符号。
如果在非特殊字符前面使用反斜杠，则反斜杠会被省略


## 字符串和数组
字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。
如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined
但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符
var s = 'hello';
delete s[0];
s // "hello"
s[1] = 'a';
s // "hello"
s[5] = '!';
s // "hello"
由于字符串是只读的，那些会改变原数组的方法，比如push()、sort()、reverse()、splice()都对字符串无效，只有将字符串显式转为数组后才能使用，

## length
length属性返回字符串的长度，该属性也是无法改变的

## 字符集
JavaScript使用Unicode字符集。也就是说，在JavaScript引擎内部，所有字符都用Unicode表示。
JavaScript不仅以Unicode储存字符，还允许直接在程序中使用Unicode编号表示字符，即将字符写成\uxxxx的形式，其中xxxx代表该字符的Unicode编码。比如，\u00A9代表版权符号。
每个字符在JavaScript内部都是以16位（即2个字节）的UTF-16格式储存。也就是说，JavaScript的单位字符长度固定为16位长度，即2个字节。
UTF-16有两种长度：对于U+0000到U+FFFF之间的字符，长度为16位（即2个字节）；对于U+10000到U+10FFFF之间的字符，长度为32位（即4个字节），而且前两个字节在0xD800到0xDBFF之间，后两个字节在0xDC00到0xDFFF之间。举例来说，U+1D306对应的字符为𝌆，它写成UTF-16就是0xD834 0xDF06。浏览器会正确将这四个字节识别为一个字符，但是JavaScript内部的字符长度总是固定为16位，会把这四个字节视为两个字符。
var s = '\uD834\uDF06';
s // "𝌆"
s.length // 2
/^.$/.test(s) // false
s.charAt(0) // ""
s.charAt(1) // ""
s.charCodeAt(0) // 55348
s.charCodeAt(1) // 57094
上面代码说明，对于于U+10000到U+10FFFF之间的字符，JavaScript总是视为两个字符（字符的length属性为2），用来匹配单个字符的正则表达式会失败（JavaScript认为这里不止一个字符），charAt方法无法返回单个字符，charCodeAt方法返回每个字节对应的十进制值。
所以处理的时候，必须把这一点考虑在内.
但是好像ES6有了这方面的api了

## Base64编码
Base64是一种编码方法，可以将任意字符转成可打印字符。使用这种编码方法，主要不是为了加密，而是为了不出现特殊字符，简化程序的处理。
btoa()：字符串或二进制值转为Base64编码
atob()：Base64编码转为原来的编码
var string = 'Hello World!';
btoa(string) // "SGVsbG8gV29ybGQh"
atob('SGVsbG8gV29ybGQh') // "Hello World!"
这两个方法不适合非ASCII码的字符，会报错。
要将非ASCII码字符转为Base64编码，必须中间插入一个转码环节，再使用这两个方法。
function b64Encode(str) {
  return btoa(encodeURIComponent(str));
}
function b64Decode(str) {
  return decodeURIComponent(atob(str));
}
b64Encode('你好') // "JUU0JUJEJUEwJUU1JUE1JUJE"
b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // "你好"







