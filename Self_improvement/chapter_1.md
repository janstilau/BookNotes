北桥的出现: 为了协调CPU,内存,高速的图形设备,使得他们可以高速的交换数据.  
南桥的出现: 专门处理低速设备的芯片,磁盘,usb,键盘,鼠标等等.南桥将他们汇总后连接到北桥.


多处理器:CPU的频率,最高也就是4G,这是物理限制的.于是人们开始从增加cpu的数量开始着手.但是,并不是cpu的数量可以和速度的提高成正比的,原因在于,有些任务是不能完全分别为不相干的子问题. 例如,女人10个月生孩子,但是10个女人不能一个月生孩子.在处理多请求,例如数据库,网络服务器上,每一个请求都是独立的,多处理器可以最大发挥威力.  
多核处理器: 多个处理器合并在一起打包.这些多个处理器,共享比较昂贵的缓存不见,只保留多个核心,并以一个处理器的外包进行出售.从程序员的角度看,和多处理器差别很小.  

**计算机科学领域的任何问题,都可以通过增加一个间接的中间层来解决**  
每个层次之间都要互相通信,既然要通信就要必须有一个通信的协议,我们一般将它叫做接口interface.接口的下面那层是接口的提供者,由他定义接口,上面是接口的使用者,使用接口来实现所需要的功能.在层次体系里面,接口是精心设计过的,尽量保持稳定不变,那么理论上,层次之间只要遵循这个接口,任何一个都可以被修改或者替换.除了硬件和应用程序,其他的中间层,只是对下层的包装和扩展.多层设计,使得各层之间保持了独立.而虚拟机,就是在硬件和操作系统之间,增加了一个虚拟层.  

应用程序编程接口applicaiton programming interface. 应用程序接口的提供者是运行库.运行库使用了操作系统提供的系统调用接口,系统调用接口往往用软中断的方式提供.  
操作系统的内核层对于硬件层来说是硬件接口的使用者,硬件是接口的定义者,硬件的接口定义决定了操作系统的内核,具体来说就是驱动程序如何操作硬件,如何和硬件通信.这种接口叫做硬件规格.hardware specification.生产厂商提供硬件规格,操作系统和驱动程序的开发者,通过硬件规格来编写操作系统.  

## 操作系统 

操作系统1. 提供抽象的接口, 2. 管理硬件资源.  
最主要的硬件资源是 cpu, 存储器, i/o设备.  
1. 不要让CPU打盹. 
	多道程序设计: 当发现某个程序暂时无需使用cpu的时候,就启动等待cpu的程序.问题在于,调度的策略粗糙.后面改进为,每个程序运行一段时间后,就主动让出cpu.这对交互式的任务特别总要,应为交互的对象是用户.用户的操作要尽快处理,这种技术叫做分时系统.要比多道复杂很多.但是,如果一个程序正在操作,比如while(1),操作系统也没办法.所以,后来改进为多任务系统了,操作系统接管了所有的硬件资源,并且本身自己运行在受硬件保护的级别上,所有应用程序都以进程的方式运行在比操作系统低的级别上,都有自己独立的地址空间,进程之间的地址空间相互隔离.cpu由操作系统统一分配,进程根据优先级来得到cpu.超过一段时间,操作系统就会停止进程,运行别的进程.这种cpu的分配叫做抢占式.cpu可以在进程间快速切换,造成同时运行的假象.
2. 设备驱动  
操作系统,对硬件进行了管理和抽象.应用程序,希望看到的是一个统一的硬件访问模式.具体的实现方式由操作系统来完成.在成熟的操作系统之后,硬件逐渐被抽象成为了一系列概念.Unix中,硬件访问和普通文件一样.程序员更多可以关注自己产品本身了.具体的硬件操作细节,交给了操作系统的硬件驱动完成.驱动可以看做是操作系统的一部分,驱动程序的开发往往是各个硬件生产厂商完成的.操作系统为厂商提供一系列的接口和框架.

## 内存  
进程的总体目标是,希望每个进程从逻辑上来看都是可以独占计算机的资源.那么如果将计算机的有限的内存分配多个程序.
之前的操作系统是直接使用物理地址.有很多问题
1. 地址空间不隔离.所有程序都访问物理地址,其他程序可以修改自己的程序.
2. 内存使用效率低.程序需要的空间是连续的,要运行一个程序,如果没有足够空间,要换出别的程序到磁盘上.这就有了大量的换入换出操作.
3. 程序运行地址不确定.之前的程序直接访问内存,换入换出则需要重定位.  

解决办法:增加中间层.用一种间接的地址访问办法. 将程序中的地址,看做是虚拟地址,然后通过某些映射的办法,将这个虚拟地址转换成为实际的物理地址.这样,只要控制这个映射过程,就能保证隔离的效果.  
对于程序来说,它并不关心复杂的存储管理策略,它只是需要一个简单的执行环境,有一个单一的地址空间,自己的cpu,程序占有计算机不被别的程序打扰.
1.分段. 分段就是把程序需要的内存空间大小映射到某个实际物理空间.每次执行指令的时候,都由映射软件将虚拟地址转化成实际地址.这就解决的13问题.但是,第二个问题没有解决.分段的时候,映射还是用的程序大小,如果内存不足,换入换出的是整个程序.其实,程序的局部性原理,一个程序运行的时候,某个时间段,只是频繁的用到了一部分数据.于是人们就想到了内存分割后映射的办法.

2.分页. 把地址空间认为等分成为固定大小的页,页大小由硬件决定.当我们把进程的虚拟地址空间分割后,加载时候,不常用的代码和数据在磁盘中,当需要的时候,在从磁盘读取.虚拟页在内存中的叫做物理页,磁盘中的叫做磁盘页.他们之间都有映射关系.当访问到不在内存的页的时候,就产生页错误,操作系统就会负责将缺失的页导入内存,然后建立映射. 而这些也中,都有权限属性,有的只能是操作系统才能访问. 虚拟存储的实现,要靠mmu,memory management unit的部件来映射.经过它我们程序中的虚拟地址,就会变成实际的物理地址.

## 线程.


线程,轻量级进程,程序执行流的最小单位.线程id,执行指针,寄存器集合和堆栈组成线程.一个进程由几个线程组成,线程之间共享程序的内存空间(代码段,数据段,堆)以及进程级别的资源(文件,信号).
线程总是并发执行的,当线程数量小于处理器数量时,是真正并发,不同的线程可以运行在不同的处理器上,互不相干.在单处理器时候,并发是一种模拟的状态.操作系统轮流执行线程,这个不断切换线程的行为叫做线程调度.
运行,就绪,等待, 线程三态.
当时间片用尽之后,线程就进入就绪,如果时间片用尽之前进程就开始等待,他进入等待态.当一个线程离开运行态时候,另外一个就绪态就开始执行.等待态的时间发生后,要进入就绪态.
线程有用优先级,对于频繁等待的线程,叫做io密集型,对于很少等待的叫做cpu密集型.
为了避免优先级低的线程被饿死,调度系统常常会逐步提升那些等待时间过长的线程的优先级.

线程安全  
因为汇编之后的汇编代码不止一条指令,而执行的时候,可能在执行完一条汇编指令后就进行了切换,所以当多个线程操作同一份内存数据的时候,常常会发生异常.而原子指令很少,所以,程序中为了达到线程安全,通常使用锁.

所谓同步,就是一个线程访问数据没有结束的时候,其他的线程不能对同一个数据进行访问.如此,数据的访问就原子化了.同步最常用的就是使用锁.每一个线程在访问数据或者资源的时候,先视图获取锁,在结束后释放锁,锁已经被占领后,试图获取锁的线程会等待,直到可以重新获取.
对于可以多个线程访问的资源,多远信号量简称信号量.一个N的信号量可以允许N个线程访问.次序如下  
信号量-1  
如果信号量小于0,等待,否则继续操作.  
访问完资源,信号量加一,如果信号量的值小于1,唤醒一个等待的线程.

互斥量和二元信号量很类似,资源只能同时允许一个线程访问,不同的是,信号量可以在系统各个线程获取释放,一个信号量可以在被一个线程获取后另外一个释放,但是互斥量则要求谁获取,谁释放.

读写锁,有三种状态,自由,共享,独占. 自由的时候,试图用任何一种状态获取锁都可以成功,共享时,其他线程可以用共享状态获取,这个锁被分配给所有共享的线程,独占的时候,其他线程不可以获取.当共享锁时要以独占获取资源时,要等待所有的共享锁释放后才能执行.


##  重入

一个函数被重入,代表这个函数没有执行完成,由于外部或者内部调用,又一次进入函数执行.
1. 多个线程同时执行一个函数.
2. 函数自身调用自身.可能经过了很多层调用后.  

函数被称为可重入,表明该函数被重入后不会产生任何不良后果.  
1. 不适用任何静态或者全局的非const变量.
2. 不返回任何静态或者全局的非const变量指针.
3. 仅仅依赖调用方的参数.
4. 不依赖任何资源锁.
5. 不依赖不可重入的函数.  


简单来说,函数可重入,代表它不会更改函数执行声明周期外的变量的值.还有就是,没有依赖锁,不然会死锁.  



























