# 例子

开始,作者给出了一个例子,Door类和TimeClient接口,有一个Timer类,在timer类内部时间到达的时候,会调用TimerClient的timeout方法.然后想要实现timerOutDoor这样的一个类,作者就这样继承了  
timerCilent -- > Door --> TimerDoor   
这样有什么问题呢.用Door继承TimerClient,就默认所有的door都要有定时功能了.但是door里面不应该有定时这种行为,这只是某种door的行为.如果创建了没有timer功能的门,还需要在里面填写timeOut的方法{},这样违反了LSP.而且,相当于在没有定时功能的类里面,都要包含timerCilent接口.  
door介入这样的一个方法,是为了给自己的子类带来好处,但是持续这样做,每次子类添加方法,都加到基类中去,这就污染了基类的接口,使他变胖了.而且,每次子类都要实现一个实现.   
而且,如果timeClient的接口设计错误,例如,需要增加一个参数,那么所有的door的派生类都要修改.但是除了timerDoor,其他所有的door都和定时没有关系啊,如果程序中的一部分更改,会影响到了无关的其他部分,那么更改的代价和影响不可预测,风险也就剧增.  

# 接口隔离原则  

不应该强迫客户区依赖他们不用的方法.  
如果客户程序依赖不用的方法,那么这些客户程序就面临着由于这些方法的改变带来的变更,增加了客户程序的耦合. 通俗点说,一个客户程序依赖了一个含有不用方法的类时候,当其他客户要求对这个类进行更改时,自己这里也要随着修改.  

## 解决办法  
上述door,timeClient 确实是需要在一个对象里一起实现.应该怎么分离.  
原则: 一个对象的客户,不是必须通过这个对象的接口来访问它,也可以通过委托或者对象的基类去访问它.

1. 建立一个转换器,这个转化器实现timeClient接口,door -> timeDoor, 转化器内部引用一个timeDoor,这样,需要timeOut的接口实现在转化器中完成,timeDoor里面可以编写和time有关的代码,而这和其他的door没有关系.timeOut的时候,转换器将调用代理给内部的timeDoor.
2. timeDoor 多重继承 door 和timeClient接口,timeDoor的指针,可以蜕变推timeClient的指针.对于time的客户程序来说,操作的仅仅是timeClient对象的智者. 而其他的door,直接继承door基类,door基类,不和timeClient 有继承关系.


## 结论 

书中的胖类,实际上指的这样一种情况.在触发器的代码里面,触发器的tree有着验证的功能,而这个验证的功能写在了document里面.我们可以把document传递给tree.document是一个核心了,拥有很多方法,而这些方法大部分是tree里面用不到的.这个时候,如果document里面有改动,比如,document的一个方法改动的时候,会影响到tree.实际上tree里面仅仅使用的document的invalidate方法.通过把胖类的接口,分解为多个特定于客户程序的接口,可以实现,每个客户程序仅仅使用了接口对象的函数.而胖类,继承所有的接口,并且实现.传入胖类的指针,但是客户类仅仅保存接口对象的之后怎.这样解除了客户程序和无关方法之间的依赖,客户程序之间也就没了依赖.
