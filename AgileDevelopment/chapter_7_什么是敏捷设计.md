### 设计的臭味   

*  僵化性    
    很难对系统改动,因为每个改动都会迫使系统的其他部分的改动.
* 脆弱性  
    对系统的改动,会导致系统和改动的地方在概念无关的地方出现问题.
* 牢固性  
    很难解开系统的纠结,难以复用组件.
* 粘滞性  
* 不必要的复杂度 -> 过度设计
* 不必要的重复.  
    代码里很多重复的结构,而重复的结构应该用单一的抽象统一.  
* 晦涩性   难以阅读.

1. 僵尸性  
    单一的改动,会导致有依赖关系的模块的连锁变动,那么设计就会使僵尸的. 开发的时候,简单的改动引起了没有预想的变化,而寻找这些变化并改动的时间远远超过了预期,那么软件的架构很有可能过于僵尸.  
2. 脆弱性.
    一个改动,许多地方就出问题.新的问题和改动的地方没有概念上的联系,改正一处其他地方就出问题.脆弱性会随着临时修改越来越强,不断地修补的,最终成为重负.
3. 牢固性.
    设计中,包含了对其他系统有用的部分,但是没有办法分离.结果只能重新实现一份类似的代码.
4. 粘滞性
    当需要修改的时候,一些方法可以保持设计,另外一些会破坏设计,也就是生硬的办法.当保持设计的办法,比生硬的办法,难以应用的时候,就代表设计有很高的粘滞性
5. 不必要的复杂
    开发人员预测变化,放置了处理变化的代码.但是,为了过多的设计准备,设计中包含绝对不会用到的代码,从而变得混乱.背负这些代码,结构复杂.
6. 不必要的重复 
    cut,paste的灾难性的代码编辑.当同样的代码,用稍微不同的形式一再出现的时候,就是表示了开发人员忽视了抽象.发现所有的重复并通过抽象去消除他们是更好的做法.当重复代码过多的时候,修改系统就变得复杂.发现的错误要在所有重复的地方修改.但是重复之间又有不同,导致修改又稍有不同,这怎么不犯错.
7. 晦涩性.
    难以理解.当当初编写代码的人员熟悉消退了之后,那些难以琢磨的magic code 就变成了修改的噩梦.有时,自以为是的编程技巧和性能的考虑也让代码难懂.

*如果我们的设计,由于持续,大量的需求变化失败,那么就代表我们的设计和实践本身有缺陷.*   

### 例子 copy程序 

最原始的copy程序是从键盘输入,在显示器输出.
```
void copy() {
    int c;
    while((c = readKeyboard()) != EOF) {
        writePrinter(c);
    }
}
```  
然后,输入变化一次,输出变化一次,为了让之前copy程序的使用者不更改接口,于是值能增加全局变量控制,在每一次用copy之前,要赋值变量相关的值.
```
bool readFormKeyboard = false ;
bool writeToPrinter = fasle;
void copy() {
    int c;
    while((c = ( readFormKeyboard? readKeyboard() : readFromOther() ) != EOF) {
        writeToPrinter? writeToOther(): writePrinter(c);
    }
}
```  
这样的程序,如果再有新的变化,难以更改,拥有很多我们之前提到的坏特性.
那么良好的设计应该怎么样呢.在第一次有修改的时候,就应该就以后的变化留出变化的结构.
```
class Reader{
    public: virtual int read() = 0;
}
class KeyboardReader {
    public: int read() {};
}
void copy(Reader &reader) {
    int c;
    while((c = reader.read()) != EOF) {
        writePrinter(c);
    }
}
```
这样的结构,以后无论什么样的读入设备,copy程序不会改变.而且,read的实现在不同的类的实现里面,不会因为增加新的设备,也就是需求变化,更改copy函数.
copy原始的程序不具有灵活性,因为依赖的关系的方向.copy直接依赖了keyboardRead和writeToPrinter.copy是一个高层模块,知道怎么拷贝字符,但是它却依赖了底层结构,需要知道键盘和打印机的实现.所以,底层实现改变,高层策略也要改变.一旦这个不灵活被暴露出来,开发人员就应该知道,需要更改设计.   
设计必须要保持干净简单,这是一个过程,是一个持续的事情.而它需要一系列的原则,去维护设计不腐败.

----





