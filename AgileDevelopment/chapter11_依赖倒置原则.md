# 依赖导致原则 

1. 高层模块不应该依赖底层模块,二者应该依赖于抽象.
2. 抽象不应该依赖于细节,细节应该依赖于抽象.  

高层模块如果包含底层模块,那么当底层模块改动的时候,就会影响到高层模块,迫使他们依次做出改动.但是,本来应该是高层模块的改动去影响底层的细节实现模块,所以,包含了高层业务规则的模块应该优先并且独立于包含了细节的模块.通过子程序库的形式,已经实现了底层模块的重用.如果高层模块依赖底层模块,那么重用高层模块就变得很困难.高层独立于底层,才可以被容易的复用. 

## 层次化  

所有的结构良好的面向对象的架构,都具有清晰的层次定义,每个层次通过一个定义良好的,受控的接口向外提供了一组内聚的服务.
每个较高层次都为它所需要的服务声明一个抽象接口,较低层次实现了这些抽象接口,每个高层类通过接口来使用下一层,这样高层就不依赖于底层了,底层反而依赖于高层中声明的抽象服务接口编程.这样,就斩断了直接的依赖关系.底层的功能改变,但是只要接口没有变,高层依然可以利用接口调用底层功能获取信息.
这里不仅仅是依赖关系的倒置,也是接口所有权的导致,我们通常认为工具库应该拥有自己的接口,但是现在确实客户拥有抽象的接口而服务者则是从这些抽象接口中派生.

这就是 donot call us, we will call you. 底层模块实现了在高层模块中声明并且被高层模块调用的接口.


## 例子 

依赖倒置,可以用在任何存在一个类向另外一个类发送消息的地方.
按钮控制电灯例子.  
最初设计   
  
```
public class Button {
	private Lamp mLamp;
	public void poll() {
		if (condition) {
			mLamp.on();
		} esle {off}
	}
}

```
首先,这个button依赖于lamp对象,如果lamp对象的on,off修改函数签名,button内部也要修改,再次,这个button只能控制电灯了.
这个程序高层底层没有分离,抽象没有和具体分离.没有这种分离,高层策略就自动的依赖底层模块.   

抽象出一个buttonServer接口来,让lamp实现这个接口,这样button可以通过接口调用被控制者.button可以控制任何实现了接口的设备了,这有很强的灵活性,但是被控制的对象有了要求,它要实现接口.但是,这个接口其实没有依赖于button,接口可以放到不同的位置,可以放到button中,也可以放在单独的头文件中,然后button,lamp同时引用这个头文件就可以了.  


##  结论

传统的过程化设计程序,依赖关系是策略依赖于细节.例如,button依赖于lamp的具体实现,这样使得策略收到了细节改变的影响.这里讲一下什么是策略,它随着具体细节改变而改变的逻辑,是对于程序控制的抽象.在button这里,就是button在检测到开关指令之后传到指令给被控制的对象.传统的过程式设计师,button被点击,然后调用lamp的方法.而面向对象的程序设计,导致了依赖关系,使得细节和策略都依赖于抽象,并且常常是策略放拥有接口.所谓倒置,是和之前的设计思路相比的导致.  






