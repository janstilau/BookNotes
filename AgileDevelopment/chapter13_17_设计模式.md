书中的设计模式只是简单的设计模式的讲解,具体还是要看gof那本书. 这里只是摘抄比较作者对于不同模式的理解.

## COMMAND 

command模式,封装的是操作,把函数层面的任务提到了类的层面.它实现了实体上和时间上的解耦.  
1. 实体上的解耦.    
command中封装的可以是简单的操作,也可以是复杂的操作.这些复杂的操作,如果直接写到gui代码里,或者写到gui的回调代码里,都可能导致重复代码.一个command可能在多处被使用,如果没有command,那么同样的代码要重复多次,而将它封装到一个对象中,将具体执行代码和gui相关代码分离,实现解耦.  
2.  时间上的解耦.   
一个操作,不一定在触发之后立马执行,比如数据库保证,在工作时间不进行存储工作,只进行读取,对于书中的例子,工资计算这种事,是合理的,因为就算更改工资计算方式,下一次工资发放,也应该是隔天,业务上不会在更改之后立马用新的规则发放工资.那么将所有的command进行存储,在午夜进行执行,这样就实现了操作的存储.如果没有command,将回调里面写满调用函数,是不能实现这种滞后操作的.   
3.   Undo操作
为了实现undo操作,需要记录本次command操作,会更改那些数据的变化.在undo的时候,将这些变化的数据重新设置到之前的数据.command的执行拥有顺序,在命令历史面板里,顺序执行所有command,每个command引起自己所影响的数据的微弱变化,合起来就是从数据开始到数据终点的所有变化.相应的,在undo的时候,每一条命令进行undo操作,回复自己影响的数据变化,退回去就应该恢复最原始的状态.需要记录变化前后的数据状态,以及在内存管理方面,如果是程序员管理内存,需要在command的析构的时候注意释放内存.因为,在数据的函数里面,因为undo的时候可能还用到某个对象,是不会delete掉这个对象的.

## TemplateMethod模式 和 Strategy模式  
这两个模式想要处理的问题都是类似的,一个是用继承解决问题,一个是用委托解决问题.  
两个模式,都是可以分离通用的算法和具体的上下文,我们有一个通用的算法,为了依赖倒置,我们想要这个通用的算法不依赖具体的实现,而是这个通用的算法和具体的实现都依赖于抽象.  

TemplateMethod的基本构架是,通用的算法放在基类里面,通过继承,在不同的具体上下文都使用这个通用算法,这就意味着,在c++环境里,这个函数不是虚函数.当然,对于动态寻找执行函数的语言,复写就意味着执行的是子类的函数了.然后在派生类里面,实现通用的算法所调用的函数,这些函数是可以被复写的,不同的子类实现不同的策略.例如,在排序算法里,如果判断顺序这样的判断算法,在现在的环境下,大量使用的闭包,如果没有闭包,只能通过构造不同的子类实现的话,那么在不同的子类里面,实现不同的排序先后规则,但是排序算法没有更改.  
这种技术有代价,因为继承是一种很强的关系,派生类不可避免的就和基类绑定在了一起.  

Strategy模式  
Strategy模式是通过代理功能给接口对象实现的.实现类和应用类通过接口进行链接,应用类通过接口,将具体的实现代理给实现类,这样的模式,增加了类的个数和间接的层次,比template相比,多一些数据开销和时间消耗.但是,应用类和实现类之间没有继承关系,耦合要小很多.

## Facade模式和Mediator模式

这两个模式共同特点在于,都是将某种策略施加到一组对象之上.Facade从上层施加策略,而mediator从下面施加策略.  
Facade 模式就是说,对于一组功能模块,编写一个调用类,app在使用功能模块的时候,要通过这个调用类进行使用.这也是我们实际中经常做的.使用Facade模式,意味着开发人员接受,所有对于这个功能模块的调用都要通过这个facade类.如果越过这个类,那么由开发人员自己控制这个模块各个数据的配置和调用.  

之所以facade在上层,是在于开发人员要通过facade类来和内部模块打交道.而mediator则是在幕后进行调节.iOS的controller就是mediator模式的应用,controller里面,包含了对于UI层各个事件的处理,包括UI改变后对于model的处理以及UI改变之后各个UI之间的配合.问题在于,mediator的责任过大,经常导致mediator层的控制过于复杂,代码混乱.

## Singleton模式和Monostate模式

类和实例之间,一般是一对多的关系,在需要的时候创建他们,在不需要的时候删除他们,伴随着内存的分配和释放.
但是有些类,只有一个实例,应该在程序启动的时候创建,程序关闭时释放.例如,程序的基础对象,工厂方法对象(创建其他对象),管理器对象(管理其他对象).这些对象,多份是错误的表现.  

单例模式   
单例模式是通过隐藏构造函数,通过静态变量存储对象,通过静态方法取得对象的一种模式,一般懒加载,  
Monostate模式  
这个模式平时没有用过,一般用的还是单例模式.简单来说,它里面所有的数据,都是静态数据,而所有的方法,都是操作这些静态数据,所有,可以创建两个对象,但是两个对象的操作,都操作了一份数据,好像这两个对象只是别名.这个模式没有把这个类是单独一份这样的事情暴露出去,用户应用的时候.
书中,对于这些类还要派生的时候的比较,不过之前的单例,都没有派生,也就没有很大的感觉.


## NULLObject模式
书中的例子是,从数据库中返回数据对象,传统的写法是,if( !value && value.isEnough()),这样很常见,但是每次都进行null判断导致代码容易出错,毕竟,有可能忘记了.NullObject就是,一个实现了数据接口的表示null的类,他实现了所有的数据接口,实现表示为,方法里面什么也不做.这个什么也不做和具体业务相关.比如,测试一个员工的出勤达到标准没,nullObject里面就返回false.  
这样看起来,和oc给null发消息一样,没有副作用,这样就可以实现接口的稳定,不用进行过多的==null的判断了.  
至于,真的想要判断是不是null的时候,可以在nullObject的类中,添加一个静态的数据,代表着nullObject类的唯一实例,在需要返回表示Null的时候,每次都返回这个实例.通过将得到的实例和这个实例进行相等判断,也就知道之前返回的是不是表示null的特殊object了.
使用nullObject模式,就是确认函数总是返回有效的值,就算是它们失败的时候也是如此,这些失败的对象,调用方法不会奔溃,只是没有都不做.























