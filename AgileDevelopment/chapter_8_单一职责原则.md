### 单一职责原则 SRP : 就一个类来说,应该仅有一个引起它变化的原因.  
  
  
 通俗的说,就是一个类只负责一项职责.  
 每一个职责都是变化的一个轴线,当需求变化的时候,如果一个类承担了多余一个的职责,那么引起它变化的原因也就有了多个.  
如果,一个类的职责过多,那么就等于把这些职责耦合在一起了,一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力.这种耦合导致fragile的设计.当需求变化的时候,可能设计会遭受破坏.  
 *举例*   
 
```
class Rectangle {
    public:
        void draw();
        double area();
}
ComputationApplication, GraphicalApplication
```
矩形类有两个功能,一是计算面积,一是绘画自己.为了让绘画能够完成,这个类就要加入gui的库.但是ComputionAppliation仅仅需要计算的功能,但是因为类中有GUI的库,相当于这个applicaiton也要用到gui的库.并且,如果GraphicalApp因为绘画的代码更改了,会导致ComputationApp也要重新编译链接.   
这个设计,矩形类有两个职责,违反了单一原则.   

## 职责
    职责,定义为变化的原因,如果有着多余一个的动机去改变一个类,那么这个类就具有了多余一个的职责.但是怎么区分是个难题.


blog:   
[单一职责原则](http://blog.csdn.net/zhengzhb/article/details/7278174)  
上面的文章主要讲,初始设计的时候,很容易设计为单一原则,因为单一原则是模块化程序的思想.但是,随着需求的更改,很容易发生一种***职责扩散***的事情.比如,我们经常要增加一个功能,但是不知道放在哪里,就放到了和这个功能有点联系的类里面.应该怎么做,  
1. 新写一个类,将功能代码放在里面.如果是那种需要多态解决的问题,改变原来的类,构造接口,将原来的逻辑改为接口编程,这样可以为之后的需求变化做准备   
2. 在原来的类的基础上写一个方法,将相关的功能方法里面  
3. 新功能和原来功能相关,在原来功能里面做修改.  
1的方法符合原则,但是太麻烦,而且会不会有那么多需求变化不知道,为了一个变化更改原来实现增加类不值得. 2算作方法的单一原则. 3最差,直接修改之前功能.但是最方便. 作者的原则是
>只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则；  


    

