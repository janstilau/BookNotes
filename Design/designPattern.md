# 设计模式

## 创建模式

* 什么时候使用

    1. 当使用场景不需要知道具体的实际类, 只需要对象是某个类型的时候
    1. 当使用场景不需要知道具体的构造过程的时候, 例如, 构造一个对象, 会有很多的配置过程, 这个过程如果在使用场景里面写会很冗余

### 抽象工厂

1. 定义一系列的产品, 这些产品有着各自的继承体系. 运用抽象工厂, 最大的好处应该是规定了产品的配套. 
1. 每个产品的获取函数, 是一个工厂方法, 而每个工厂方法, 返回一个基类的指针.
1. 子类的职责是, 实现所有的工厂方法, 从而子类工厂可以返回各自实际的产品.

### 简单工厂

* 当只有一个产品的时候, 抽象工厂可以退化成为简单工厂方法, 这个时候, 也不需要定义各个子类工厂来实现各个子类产品的创建, 因为只有一个产品的产出. 这个时候, 可以运用参数化的函数, 将想要生成的产品, 通过参数进行区分, 然后在简单工厂的工厂方法里面, 根据不同参数产生不同的产品, 然后返回这个产品.
* 类簇模式里面, 用到了简单工厂模式.

### 工厂方法

* 在苹果的设计里, 工厂方法返回一个实例来, 工厂方法一般是一个类方法, 运用了工厂方法就不用alloc init了, 并且在MRC的时代, 工厂方法是被添加到了自动释放池中, 所以也不用程序员去release了.
* 但是工厂方法的实际意义在于, 返回父类, 返回父类对应的产品, 子类返回子类对应的产品, 这些产品有着一个共同的基类, 在客户代码那里, 使用这个基类的功能进行操作. 而具体的实现细节, 写到各个实际的产品类中. 所以在抽象工厂那里, 使用了工厂方法这种模式, 抽象工厂里面, 返回的是产品的基类type, 而各个实际的工厂类里面, 返回的是实际的产品. 通过工厂方法的这种特定, 抽象工厂那里实现了对于产品的配套管理, 让一个工厂产生的产品, 是同一个系列的. 

### 单例

* 最简单的设计模式, 它的好处在于
    1. 可以保证, 只有一个实例对象的存在.
    1. 提供了内存空间, 而有了内存空间, 就可以保存数据. 这是一个只有方法的工厂类不能够提供的.
    1. 至于书中所说, 单例类的继承, 基本没有用到过.

## 行为型模式

### template模式

* 主要结构为, 基类定义框架, 子类实现细节. 在基类里面, 定义纯虚函数, 要子类实现, 而基类的其他函数, 调用这些纯虚函数. 这些纯虚函数, 各有各自的功能, 或者更新数据, 或者返回一个数据作为后续的操作. 基类知道的, 只是这些纯虚函数的职责, 但是知道了这些职责, 就可以搭建出一个逻辑清楚的方法出来. 例如, 在NSArray里面, 可以primitive方法就两个, 一个是count, 一个是objectAtIndex, 但是, 知道了这两个方法的职责, 就能将Array的其他功能, 例如, lastObject, firstObject写出来. 在绘图的类里面, 基类编写了对于各个信号的处理, 各个信号的处理具体实现不相同, 但是都有计算绘制区域和paint方法. 子类仅仅是需要实现计算的代码, 和paint方法, 还有就是具体的数值的存储.

* 在苹果的类簇模式下面, 其实是大量用到了template模式. 具体的存储细节, 需要子类完成, primitive方法, 也是需要子类实现, 但是, 其他的功能方法, 可以通过调用这些primitive方法实现. 子类需要修改的, 仅仅是这些primitive底层方法, 其他的框架逻辑, 在基类中已经完成.

* 在日常, 其实运用了大量的这种设计, 只不过没有在意而已.