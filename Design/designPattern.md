# 设计模式

## 创建模式

* 什么时候使用

    1. 当使用场景不需要知道具体的实际类, 只需要对象是某个类型的时候
    1. 当使用场景不需要知道具体的构造过程的时候, 例如, 构造一个对象, 会有很多的配置过程, 这个过程如果在使用场景里面写会很冗余

### 抽象工厂

1. 定义一系列的产品, 这些产品有着各自的继承体系. 运用抽象工厂, 最大的好处应该是规定了产品的配套. 
1. 每个产品的获取函数, 是一个工厂方法, 而每个工厂方法, 返回一个基类的指针.
1. 子类的职责是, 实现所有的工厂方法, 从而子类工厂可以返回各自实际的产品.

### 简单工厂

* 当只有一个产品的时候, 抽象工厂可以退化成为简单工厂方法, 这个时候, 也不需要定义各个子类工厂来实现各个子类产品的创建, 因为只有一个产品的产出. 这个时候, 可以运用参数化的函数, 将想要生成的产品, 通过参数进行区分, 然后在简单工厂的工厂方法里面, 根据不同参数产生不同的产品, 然后返回这个产品.
* 类簇模式里面, 用到了简单工厂模式.

### 工厂方法

* 在苹果的设计里, 工厂方法返回一个实例来, 工厂方法一般是一个类方法, 运用了工厂方法就不用alloc init了, 并且在MRC的时代, 工厂方法是被添加到了自动释放池中, 所以也不用程序员去release了.
* 但是工厂方法的实际意义在于, 返回父类, 返回父类对应的产品, 子类返回子类对应的产品, 这些产品有着一个共同的基类, 在客户代码那里, 使用这个基类的功能进行操作. 而具体的实现细节, 写到各个实际的产品类中. 所以在抽象工厂那里, 使用了工厂方法这种模式, 抽象工厂里面, 返回的是产品的基类type, 而各个实际的工厂类里面, 返回的是实际的产品. 通过工厂方法的这种特定, 抽象工厂那里实现了对于产品的配套管理, 让一个工厂产生的产品, 是同一个系列的.

### 单例

* 最简单的设计模式, 它的好处在于
    1. 可以保证, 只有一个实例对象的存在.
    1. 提供了内存空间, 而有了内存空间, 就可以保存数据. 这是一个只有方法的工厂类不能够提供的.
    1. 至于书中所说, 单例类的继承, 基本没有用到过.

## 行为型模式

### template模式

* 主要结构为, 基类定义框架, 子类实现细节. 在基类里面, 定义纯虚函数, 要子类实现, 而基类的其他函数, 调用这些纯虚函数. 这些纯虚函数, 各有各自的功能, 或者更新数据, 或者返回一个数据作为后续的操作. 基类知道的, 只是这些纯虚函数的职责, 但是知道了这些职责, 就可以搭建出一个逻辑清楚的方法出来. 例如, 在NSArray里面, 可以primitive方法就两个, 一个是count, 一个是objectAtIndex, 但是, 知道了这两个方法的职责, 就能将Array的其他功能, 例如, lastObject, firstObject写出来. 在绘图的类里面, 基类编写了对于各个信号的处理, 各个信号的处理具体实现不相同, 但是都有计算绘制区域和paint方法. 子类仅仅是需要实现计算的代码, 和paint方法, 还有就是具体的数值的存储.

* 在苹果的类簇模式下面, 其实是大量用到了template模式. 具体的存储细节, 需要子类完成, primitive方法, 也是需要子类实现, 但是, 其他的功能方法, 可以通过调用这些primitive方法实现. 子类需要修改的, 仅仅是这些primitive底层方法, 其他的框架逻辑, 在基类中已经完成.

* 在日常, 其实运用了大量的这种设计, 只不过没有在意而已.

### 命令模式

* 命令模式可以让请求者和接受者分离, 请求者并不知道接受者到底调用了什么方法. 但是, 请求者要知道接受者是谁, 只不过接受者的方法, 是封装在了command的内部而已. 如果没有用command模式, 我们在一个按钮, 一个itemselect的回调里面怎么写, 在回调方法里面, 要组织好数据, 然后直接调用接受者的方法, 让接受者更新自己的数据. 这么看, 其实还是知道接受者的方法的. 因为我们在写这个command的时候, 其实是知道这个command内部的写法的. 因为不同的场景下, 铁定是调用的不同的command, 实际的UI回调的类里面, 铁定是要包含最终实际的command头文件的. 但是, 这个具体的调用的代码, 被封装到了command里面.

* 这样写和直接调用有什么好处呢. 首先, 这是封装, 也可以理解为函数的封装. 在其他有着相同动作的ui的回调里面, 直接构造这个command就可以了. 如果要修改, 修改command的redo, undo就可以了.

* 但是更加重要的是, undoredo这条线可以被我们建立起来. 在qt里面, commoandStack是qt系统提供给我们的, 其实我们可以想象, 这个stack应该怎么写呢, 是不是每次插入之后, 其实是调用了这个command的redo方法了呢. 然后, 每次undo的时候, 其实是依次调用了这个stack上command的undo方法了呢. 之所以在写command的时候, 没有感觉运用到太多的抽象, 是因为qt系统里面, 已经把这层抽象做完了. 我们写的, 是存储状态的代码和实际操作的方法的调用, 而回溯和重做的操作, 是在系统提供的框架里面完成的.

* 更加重要的是, command模式的每个command里面, 存储了状态, 这样我们可以进行操作的时间回溯操作. 而且, 数据也是保存在command的内部的, 所以应该注意, 在没有arc的时候, 是要在command内部把内存释放的. command模式, 最重要的就是, 保持这条线的稳定, redo, undo, 一定是数据的完全回溯. 如果一个redo, 改变了2个数据, undo, 复原了一个, 那么在多次运行之后, 一定会出问题的.

### 观察者模式

#### 观察者模式想要解决什么

一个对象, 状态改变了, 想要通知别的对象. 在书中是这样实现的, Subject中管理这一个列表, 这个列表里面是实现了某个协议的对象, 将一个对象添加到列表之后, 在Subject的状态改变的时候, 调用notify方法, notify方法的内部会遍历整个列表, 调用每个列表内观察者的update方法. 这样, 就实现了, Subject对象通过协议的方式, 将自己的变化通知到了别的对象. 用协议抽象通信机制, 使得Subject不用知道具体是哪个类想要监听数据的变化.

* pull还是push.

在调用update的时候, 应该讲变化的点告诉每一个观察者. 这个时候, 有三种策略

1. 用参数的形式, 将变化的点通知到观察者. 不过, 要判定到底是哪些参数. 因为这是一个协议, 实现协议的观察者想要的数据各不相同, 很有可能是一个观察者仅仅是需要知道事情发生了变化, 而另外的观察者需要许多参数. 那么这个接口就要按照需要最多的参数的函数签名来设计. 这个时候, 其实添加一个新的观察者, 可能就要引起之前的接口有变化, 因为新的观察者只要需要新的数据, 就要增加参数. 也可以用map, 用keyValue的形式, 将需要的值填入到map中, 这其实还是把不同的参数传出去, 但是可以让接口简化. 这样写, 需要有一个地方, 存储不同的观察者需要的键值, 一般是需要额外的头文件管理这些信息.

1. push, 也就是, 将Subject整个当做参数推出去. 这样写的好处在于, 不用关系参数的问题, Subject整个对象被push到了观察者那里, 观察者可以用Subject的get方法, 重新刷新自己的状态, 也可以添加一个参数, 说明引起变化的原因, 不过, 大部分的数据获取, 都可以在Subject中获取到. 这样写的好处是, 简化了数据交互的设计, 但是也把Subject暴露给了观察者.

1. pull, 这样是需要两个协议的, 或者需要观察者保存subject的一个引用(这样不太好). update仅仅是通知, 变化了, 然后观察者通过接口的形式, 或者subject的引用, 取值刷新.

#### targetAction

* Cocoa uses the target-action mechanism for communication between a control and another object. Provide the translation between event and instruction.  Control stores an action as an instance variable of type SEL

* 首先, 这也是Observer模式. NSControl是一个将事件和事件触发的回调进行绑定的中间协调者. 但是, NSControl的状态变化, 也是数据的变化, 在NSControl的状态变化之后, 需要通知给别的对象, 这也是Observer模式的使用场景. 由于OC的特性, 调用方法的本质是发送消息, 而发送消息, 是可以通过SEL来进行的, 也就是只要知道参数, 知道函数原型, 就可以调用, 具体调用时在Runtime层进行的处理. 所以, 在target-action里面, 定义接口的操作可以省略, 相对应的, NSControl里面, 存储的对象从只需要监听者对象, 变为了监听者对象 + 回调函数. 还有就是, NSControl有着一系列的状态变化, 在addTargetAction的时候, 可以指定状态变化的触发条件. 所以, NSControl内部, 还记录了哪个事件触发后, 给监听者发送消息. 不过, 本质来说, 这还是监听者模式.

#### nsnotification

* 通知的这个机制, 让我们可以控制什么时候发通知, 什么对象接受通知, 接受什么通知. 而一般发通知的时候, 都是想要对象的接受者进行状态的更新操作. 通知的发送和接受, 都是通过了NSNotificationCenter这个类, 也就是, 这个类是所有通知的一个协调者. 协调者模式. 之前简单的模拟了一些通知中心的设计, 是用到了发送者地址, sel字符串, 接受者地址, 简单来说, 就是发送一个通知之后, 需要通知中心根据自己存储的数据结构, 找出接受者, 接受者的方法, 然后调用这个接受者的这个方法, 这也是, 为什么发送一个通知之后, 接受者的处理函数会在同一线程里面的原因, 因为, 发送通知这个事情, 背后其实是一系列的函数调用的关系.

#### singal-slot

* 信号槽机制, 和通知中心的设计很像, 只是数据方面, 没有包装在notification内部, 而是通过了函数的形式进行了传递.

## 结构型模式

### composite模式

* 只要有树形关系的, 都可以用这个模式来进行管理. 树形关系, 最常见的就是View视图了, 一个视图, 可能有自己表现, 外观, 但是也可以在这个视图上增加自己的子视图, 而子视图和父视图一样, 有自己的表现, 也可以增加自己的子视图. 于是, 抽象出管理视图层级关系的类作为视图类的基类, 在基类里面, 写关系代码, 在各个子类里面, 写各个子类的行为, 外观表现. 这样, 在管理关系的时候, 其实是用的view的基类接口. 我们在添加subview的时候, 其实是用的UIView的接口, 这个view到底是什么View类, 其实和添加视图的操作没有关系的.

* 在触发器的代码里面, 其实无论是触发器, 还是consition, action, 之间都存在着层级关系, 而每个子类的其实就是包含不同属性的一个内存块而已, 在展示的时候, 统一是调用属性化的代码, 在各个子类上其实并没有太多的专属于子类的方法. 所以, 定义好LogicElement管理层级关系的代码至关重要.

```C++
public:
    // parent-child link
    LogicElement *parent() const;
    const QList<LogicElement *> &children() const;
    void removeChild(LogicElement *child, bool clean = false);
    int indexOfChild(LogicElement *child);
    void addChild(LogicElement *child);
    void replaceChild(LogicElement *childOld, LogicElement *childNew, bool clean = false);
    virtual void insertChild(int index, LogicElement *child);
    bool isParentOrSuperParent(LogicElement *element);
    bool traverseChildren(std::function<bool(LogicElement *)> func);
    bool traverseChildrenReversely(std::function<bool(LogicElement *)> func);

protected:
    int mType;
    QString mId;
    QString mName;
    QString mClassName;
    QList<UElement *> mChildren;
    UElement *mParent;
```

* 上面的代码, public下面是暴露出去的管理关系的接口, view类的关于层级关系的接口, 都是在这实现的. 而成员变量里面, list和parent管理关系的数据. 而在成员变量中, 由于c++没有内省机制, 所以是用成员变量的方式, 利用自定义的枚举值存储在mType里面来进行类型的管理, mClassName记录各个类的名字, 这在可以内省的语言中, 是在语言层面完成的. 在地图编辑器中, 各个图层的类型, (图块图层, 对象图层)就是根据一个mType的成员变量来进行识别的, 而具体的业务中, 有着城市图层, 资源图层, 这个的分辨是根据自定义属性中的一个type自定义属性完成的. 虽然, c++没有着内省机制, 但是我们可以通过自己来模拟. 在tiled里面, 判断一个图层类型之后, 然后将这个类型强转成为一个子类对象, 这里的代码是这样写的.

```C++
bool isTileLayer() const { return mLayerType == TileLayerType; }
TileLayer *Layer::asTileLayer()
{
    return isTileLayer() ? static_cast<TileLayer*>(this) : nullptr;
}
if (someLayer.isTileLayer) {
    auto layer = someLayer->asTileLayer();
}
```

* 上面的代码, 通过成员变量的校验, 然后做强转操作. 有了一层自己做的检验机制.

### Strategy模式

* 策略模式是被描述成为封装方法的模式. 基本思路在于, 定义一个基类, 这个基类只有几个方法的调用, 然后定义一些子类, 实现这几个方法的调用. 然后通过组合的方式, 在一个类的内部, 包含一个对于这个基类的引用, 或者实例变量, 然后在需要执行的时候, 将具体的实现, 交由这个实例变量去实现.

* 这样看起来, 策略模式和其他很多模式的实现架构相似, 都是用成员变量的方式, 引用一个基类指针, 然后通过更换这个指针, 达到替换的效果. 因为, 用多态的方式, 实现变化, 其实就是这样的一种模式, 不同的是, 他们想要达到的目的不同.

* 策略模式, 被归在了行为模式的下面, 它所注重的是某个算法细节实现和业务类的分离. 比如, 比较函数, 排序函数, 这些东西, 业务类只是调用以下而已, 和业务类的具体的实现无关. 把这些算法写在了业务类里面, 首先业务类的代码会剧增, 其次, 这些逻辑本身和业务类无关, 增加这些逻辑会让组织混乱. 如果还要有不同的算法, 让程序可以进行替换, 那么这个类会剧增. 无论是把算法组织成为函数, 还是直接写在例如排序函数内部(通过一个枚举控制当前的算法类型, 然后一个大的switch程序, 不同的分支上写不同的排序算法), 都让代码难以管理.

### mediator模式

#### 为什么会有mediator模式

我们在设计类的时候, 在不知道类和其他类通信的时候, 一般都是将类设计的高内聚, 然后发现需要和其他类进行交互了, 就设计许多的通知函数. 这在qt里面很常见, 一个数据类, 有着自己的逻辑关系, 然后发现自己需要将自身的变化暴露出去, 就写了一个信号发射函数, 将某些属性变化的前后发出去了, 当这个数据类又有了一个观察者, 这个观察者需要的是另外一些属性的变化, 就又写了一个信号发射函数, 将另外一些属性发射出去了.

这样写, 这个数据类一直在变化, 而变化的方式, 是因为不断的要和新的对象进行交互, 但是, 其实类的get, set都已经将这些东西暴露出去了啊. 不过, 由于是Subject和Observer直接交互的, 所以需要不断的修改通知的方式, 让observer可以及时更新.

我们在编写界面类的时候, 经常会有重绘操作, 这个重绘操作怎么写的呢. 取值, 然后重绘, 当paint, 或者drawRect的时候, 不是只取发生变化的那部分界面的值, 然后重绘那一小部分, 而是将整个绘制的代码写在那里. 真正的渲染引擎可能会只渲染发生变化的那一块, 但是我们的绘制代码确实界面上所有的绘制逻辑.

如果, 提供一个协调者, 协调所有的状态变化, 那么之前所需要解决的不同对象之间通信的问题也就可以解决了.

#### ViewController

VC为什么这么复杂, 因为太多的逻辑在里面. 在一个View的状态发生变化了之后, 他通过targetAction模式, 将事件变成了VC的函数, 而这个函数的内部应该是一个applicationSpecific的逻辑. 首先应该做的, 就是数据的更改, 将数据维护到view的事件引发的变化上. 然后还有一点vc要做的, 就是协调数据, 不同界面之间的关系. UI是最复杂的逻辑, 因为这部分的逻辑, 经常是和具体业务需求绑定的最紧的. 比如, 一个按钮按下之后, 所有的界面需要某个效果, 一个数据变化之后, 某些界面需要隐藏, 如果是tableView或者collectionView的话, 没准还要更改数据源, 将某些数据剔除后重新reload. 这些其实都是需要中间有个VC负责的.

因为, 用的都是apple开发好的类库, 没有机会修改用到的系统类, 所以自然而然的将协调的工作写到了VC上面, 如果是自己写的类, 又没有中间VC的存在, 那么很容易就形成了, 得知某个观察者需要某些数据, 然后就写一个信号方法, 将这个数据发出去. 久而久之, 这个类就和业务联系的太紧密了, 难以重用.

如果有一个协调者存在, 如果数据变化了, 仅仅发一个信号到协调者身上, 协调者是知道所有的对象的引用的. 所以, 他可以按照逻辑, 取某个对象的值, 检测, 然后根据结果更新其他对象的数据. 这个操作, 是刚才写的所有的线的集中, 也就是把杂乱无章的各自通信, 变成了汇集到一点的通信. 这样看来, 协调者是很难重用的. 因为包含了太多的协调性的代码, 这些代码, 是需要知道所有的对象的前提下, 进行编写的.