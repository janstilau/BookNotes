# Class

## ADT 抽象数据类型

抽象数据类型, 是指一些数据以及对于这些数据进行操作的集合.这些操作既向程序的其他部分描述了这些数据是怎么样的, 也允许程序的其他部分来改变这些数据. 许多人开发出来的名义上的类, 只不过是把一些稍微有些关系的数据和子程序堆在了一起. 抽象数据类型, 可以让程序员像现实世界一样操作实体, 而不是在底层的实现上摆弄实体.

书中举了一个修改字体的例子, 修改字体包括修改字号, 字体family, 格式, 修改字号又包括像素单位的还是磅单位的, 如果是用一个结构体来记录数据的话, 那么首先, 这个结构体的数据结构要暴露给外界, 外界才能修改或者读取数据, 再次, 很多实现的细节要暴露出去, 而这些细节暴露出去可能会有很大的风险, 比如, 粗体的设置可能是 font.attribute or 0x02这样的一句代码, 这就要修了每个设置粗体的位置都要这么写, 且不说要每个人员都要熟悉0x02代表粗体, 单就这样的写法, 就很容易写错, 也不好调用. 这样的写法, 要求了调用方代码直接控制了数据成员.

## 使用ADT的好处

1. 隐藏实现的细节, 意味着, 如果要修改内部实现, 比如数据类型, 只用修改一个地方而不是所有的程序. 这样可以将实现和调用分层, 主要接口不变, 类的内部的修改不会对整个程序造成大的修改.
1. 让接口可以提供更多的信息. 函数名有着一个很大的作用, 就是自我说明, 通过接口名可以让使用者不用查阅太多的东西就知道这个接口调用后会产生什么后果, 而不是去写丑陋的 or 0x02这样的代码.
1. 无需在程序中传递大量的数据. 其实类的接口最后还是用传递数据实现的, 但是在我们看来, 类的内部保存类的接口需要的所有数据. 如果要用C代码模拟这个效果, 势必每个操作都要传递结构体指针过去.
1. 操作实体而不是操作底层实现. 一个班级类, 增加学生, 减少学生, 都是站在班级的级别考虑问题, 而如果是一个List<Struct stucent>这样的结构, 每一个操作都要考虑内部的实现方式. 在用到班级类的调用者来说, Ta不应该知道, 也不应该考虑这些实现的问题.
1. 将常见的底层数据类型创建成为ADT, 而不再使用这些底层数据. 堆, 栈, 队列, map, hash, 这些在语言层面都进行了封装, 我们也会用这些数据类型, 而不是自己去实现一套. 在定义这些高级对象的时候, 也是直接使用这些封装好的类作为内部实现存储, 利用系统提供的抽象, 实现自己的抽象.

## 良好的类接口

创建高质量的类, 最重要的异步, 就是创建一个良好的接口. 通过接口, 来展示合理的抽象, 并且确保细节被隐藏在抽象背后.
抽象, 是一种用简化的形式来看待操作的能力, 类的接口, 应该是一组明显相关的子程序.
至于, 类的内部的子程序和数据, 使用者不应该去了解他们. 类的接口每一个子程序都应该朝着这个一致的目标工作.如果类的接口不能表现出一致的抽象, 那么它的内聚性就很弱, 所以, 如果类的接口中有很多无关的操作, 应该把这些操作重新划分到只能更加专一的类中去, 在这些类中, 提供更好的抽象.

### 接口的建议

1. 应该有着一致的抽象层次. 这其实和单一功能原则是一致的, 如果接口不一致, 很有可能就是, 这个类承担了太多的职责.
1. 一定要理解抽象是什么. 书中例子是, 用一个已有的复杂类来实现一个简单功能的类, 简单功能类可能就几个接口, 而复杂类有着十几个, 既然我们要实现的是简单功能的类, 那这个类就应该只暴露这些简单功能的接口, 而将具体实现的复杂类的接口完全的包裹住.
1. 提供成对的服务. 如果一个接口的对应服务很显而易见, 例如增加就应该有删除. 就应该在设计的时候将对应功能补全.
1. 不相关的信息, 移到别的类.
1. 防止修改的时候, 破坏接口的抽象.
    书中的例子是, 员工类在增加了sql实现之后, 增加了很多数据库相关的操作, 但是, 员工类是在员工怎么样存储更高一级的抽象.

## 良好的封装

抽象是提供一个忽略实现细节的模型来管理复杂度, 而封装则强制阻止让你看到细节. 这两个概念相关是因为, 没有封装的时候, 抽象往往会被打破, 一般来说, 这两个概念要么都实现的很好, 要么都没有实现.

### 建议

1. 不要暴露成员数据出去.
1. 不要把私有实现, 放到接口里面去.
    这一点, 由于C++的实现方式, 在头文件中实际上是可以看到实现的细节的, 书中给的建议是, 有一个implementation类, 头文件暴露的只是这个类的指针, 而这个类是在cpp中定义出来的.
1. 不要对类的使用者做出任何的假设.
    例如, 千万不要写这种注释, 必须先给某些值赋值才能进行某些操作, 而是在程序里, 发现值不对要做一些错误处理.
1. 让阅读代码比编写代码方便.
    阅读代码的时间要比编写的次数多得多. 为了调用方便, 比如把一个私有实现暴露出去让别的地方好调用, 而不是重新设计, 在开发的时候看着节省了时间, 但是之后会给后续工作代码很大的影响.
1. 不要从语义上破坏封装性.
    比如, 你看过了类的实现, 知道了, 在某个函数调用的时候, 一定会调用初始化函数, 于是就省略了初始化函数, 这样就是透过了接口编程, 如果后来这个实现改变了呢, 这样根本就不是在面对接口编程.

## 包含关系

包含, 就是表示一个对象含有一个基本数据元素或者对象. 因为继承的实现容易出错, 所以对这方面的介绍也很多, 但是包含才是面向对象的主力技术.

1. 包含是有一个的关系
1. 警惕用着7+-2数据成员的类, 如果都是简单数据成员, 7 + 2, 如果复杂的多, 7 - 2. 如果超过了, 就应该考虑分割类了.

## 继承关系

继承的概念是, 一个类是另一个类的特化, 继承的目的在于, 通过定义能够为两个或者更多派生类提供共有元素的基类的方式来写出更加精炼的代码. 所以, 派生类应该是完全符合基类的接口契约的, 如果派生类并不是这样的, 就不应该用继承. 调用者, 通过L替换原则, 应该完全不用了解基类和派生类的实现差异.

1. 仔细考虑应该继承什么. 如果只是想要继承接口(例如一个类的接口另外一个类也都需要, 但是它们实现应该不同), 或者只是想要继承实现(例如一个类需要用到基类的实现, 1. 可以包含基类对象, 调用对象的方法, 2 继承基类, 自己自动也有这个实现了, 这种情况就应该用包含, 因为自己根本就不符合是一个的含义)
1. 不要覆盖一个不可覆盖的成员函数. 子类写一个父类的成员函数. OC里面, 多态了, C++里面, 没有, 这样写本身就会产生问题.
1. 尽可能把公用的放在一个比较高的位置. 直到你发现, 已经破坏了抽象性, 就该停手了.
1. 只有一个实例, 或者一个派生类的基类是值得怀疑的.
1. 避免继承太深, 实际上, 我们写的代码, 如果2-3层, 就已经让人控制不住了. 当然, 不算从系统继承过来的系统类.
1. 尽量用多态来减少switch

* 如果你想基类控制接口, 用继承, 如果想自己控制接口, 用包含.

## 成员函数和数据成员

### 建议

1. 尽量控制数量
1. 尽量减少对于其他类的子程序的间接调用. 例如, A创造了B, 那么B的程序可以调用, 而B返回的C对象, 不应该在A里面调用.

## 建立类的原因

1. 现实世界建模
1. 抽象对象建模
1. 降低复杂度, 调用者在类的层次上编程, 不考虑内部细节
1. 隔离复杂度. 修改类的实现, 不会对其他地方影响.
1. 隐藏实现细节.
1. 让参数传递更加顺畅.
1. 建立中心控制点
1. 将相关操作包装成一个整体.
1. 重用