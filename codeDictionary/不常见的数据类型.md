# 不常见的数据类型

## 结构体

结构体指的是, 使用其他类型组件的数据. 通常情况下, 你会希望创建类而不是结构体, 这样除了能够使用结构体可以使用的公用数据成员之外, 还能利用私密性和功能性. 但是有的时候, 直接操作成块的数据会很方便.

## 用结构体的理由

1. 用结构体来明确数据关系.
1. 用结构体来简化对数据块的操作. 这里主要是数据传递的问题, 结构体是整块的传递数据, 如果一组值没有包装成为结构体, 那么要传递这些值, 就要写很多个赋值语句 或者 很多个参数. 但是, 要避免仅仅为了方便, 将无关的数据绑定在一起. 信息按照need-to-konw的原则来进行传递.
1. 便于维护. 如果要修改结构体里面的字段, 对于这些字段有影响的地方, 自然会报错提示, 这个报错可以帮助我们查找错误. 而对于没有影响的部分, 不会有影响, 原来的代码还是照常运行.

## 指针

从概念上来看, 指针包括两个部分, 内存中的某个位置, 以及如何解释这个位置的内容.

### 内存中的位置.

指针的值

### 如何解释指针所指的内容

如何解释指针指向的内容, 是由指针的基类型决定的. 对于同样的一块内容, 基类型不同, 取到的值也是不同的. 因为, 内存里仅仅是存储二进制数据, 内存里并不知道这些数据是什么.

### 一般技巧

1. 一般错误在于, 指针指向了不该指向的位置. 并且, 指针错误和引起指针错误的操作无关, 所以调试要花费大量的时间.
1. 尽量避免 + 尽快检测. 所以针对指针, 增加一些必要的检测代码很有必要.
1. 把指针操作限制在子程序或者类中. 这样减少了方位指针的代码量, 这样修改也不会影响其他部分.
1. 声明+定义. 必须确保指针是一个有效值.
1. 在指针分配的作用域里面删除指针. 就是保持指针分配和释放的对称. 如果一个子程序里面分配了内存, 然后指望调用它的代码来释放, 这很容易出问题.
1. 使用之前检查.
1. 先检查指针引用的变量, 然后在使用它.
1. 利用标记字段, 这也是oc里面, 日本人那本书里面, 模拟引用计数的办法. 在内存开始位置, 有一个专门检测错误的字段, 如果释放了这个内存, 这个字段就是个非法值, 那么在此释放之前, 检查这个值, 如果是非法值, 就代表这块内存被破坏了, 不应该在被操作.
1. 用指针变量增加代码清晰度. 不要把同一变量, 用在多种用途上.
    if(currentNode->next != NULL)
    currentNode->next->previous = sth
    这个时候, 就应该Node *followingNode = startNode->next
1. 还是上面的例子, 多级 a->b->c这种操作尽量减少, 用变量替换是很常见的选择.
1. 粉碎垃圾数据. 在每次释放数据之前, 将里面的值清空, 这样下次访问到被释放的内存的时候, 里面的值会是无效值.
1. 释放内存后, 成员变量 = null.
1. 理解引用和指针的区别. 最重要的区别就是, 引用必须引用一个对象, 而指针可以指向空值, 还有, 引用指向了一个对象之后是不可以更改成为指向另外一个对象的.
1. 熟悉智能指针.

## 全局数据

全局数据, 在程序中任意一个位置都可以访问.

1. 全局数据, 代表着任何程序都有可能改变它. 所以, 不能保证在调用了一个函数之后, 它的值还是我们想要的值. 函数有没有改变全局数据的副作用, 不进去阅读源码不清楚.
1. 别名问题.
1. 代码重入问题. re-entrant.
1. 阻碍代码重用. 一个程序的代码, 不能用去另外一个程序, 因为那个程序没有全局数据. 这样使得重用很复杂.
1. 初始化问题. 用全局数据初始化一个量, 但是这个时候全局数据还没有初始化呢.

