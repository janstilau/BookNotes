# 前期准备

造成准备工作不充分的一个常见原因就是, 那些分配去做前期准备的开发人员, 并不具备完成这一任务的专业技能. 项目规划, 分析需求, 创建高质量的架构等活动, 都需要一定的技能, 并不是轻而易举就获得的.

一定要克服尽快开始编码的欲望.

程序员是软件食品链的最后一环, 架构师吃掉需求, 设计师吃掉架构, 而程序员则消化设计.
发现错误的时间, 要尽可能的接近引入错误的时间. 缺陷在软件食物链里面呆的时间越长, 对食物链的后面就造成越多的损害. 由于需求是首先完成的事情, 需求的缺陷就有可能在系统中潜伏更多的时间.

开发商业系统的项目, 往往受益于高度迭代的开发法, 计划, 需求, 架构的活动, 和架构, 系统测试, 质量交付的活动交织在一起.

## 软件的设计

软件设计, 一词意味着去构思, 创造, 发明一套方案, 把一份计算机软件规则说明书, 变换成为可以实际运行的软件. 设计就是把需求分析和编码调试链接在一起的活动. 好的层次设计, 能够提供一个可以稳妥容纳多个低层次设计的结构.

设计是险恶的, wicked, 你必须首先把这个问题解决一边才能够明确的定义它, 然后才能再次解决它.

设计是无章法的, 在过程中, 你会采取很多错误的步骤, 犯很多错误. 犯错才是设计阶段的关键, 在设计阶段犯错, 要比编码后发现错误的代价小的多. 并且, 你并不知道, 设计怎么程度才是足够好. 

设计, 就是确定取舍和调整顺序的过程. 设计者工作的一个关键内容, 就是取衡量彼此冲突的各个设计特性, 并且尽力在其中寻求平衡. 快速反应和缩短开发效率, 哪个更重要, 是会导致不同的设计的.

设计是不确定的, 受到诸多限制的. 是在不断地设计评估, 非正式讨论, 写测试代码, 修改代码过程中演化完善的.

### 设计的关键概念

1. 软件的首要技术使命, 管理复杂度.
    项目如果是技术原因导致失败的, 原因通常就是失控的复杂度. 有关的代码变得极端复杂, 让人不知道它到底是干什么的, 修改一处代码, 没人知道对于其他代码有什么影响, 项目也就停止了.

    没有谁的大脑, 能够容得下一个现代的计算机程序, 作为一个开发人员, 我们不应该试着, 在同一时间就把整个程序都塞进自己大脑, 应该试着用某种方式, 来组织程序, 以便能够在一个时刻可以转注意一个特定的部分. 这样就是为了, 尽量减少同一时间, 要考虑的程序的量.

    再软件架构的层次上, 可以通过把整个系统分解为多个子系统来降低问题的复杂度, 人类是易于理解许多简单地信息, 而不是复杂的信息. 所有的软件设计, 目标都是把复杂的问题, 分解为简单地部分. 子系统之前, 相互依赖的越少, 越能容易在同一时间专注问题的一部分. 精心设计的对象关系, 能让关注点相互分离, 从而在每个时刻, 只关注于一件事情.

    保持子程序的短小, 也能减少思考的负担, 从问题的领域着手, 而不是从实现细节去编写程序, 在最抽象的层次上工作, 也能减少人的脑力负担.

1. 把任何人, 同一时间需要处理的本质复杂度量减少, 不要让偶然复杂度无谓的快速增长.

1. 良好设计特征

    * 最小复杂度, 设计的首要目标, 就是复杂度减少, 避免做出聪明的, 但是难以理解的设计, 而是简单地易于理解的设计. 如果, 设计方案, 不能让你专注于程序的一部分, 而安心的忽视其他部分的时候, 设计就没什么用.
    * 易于维护
    * 松散耦合 程序的各个部分, 组成成分之间的关联最小. 利用类接口的合理抽象, 封装性, 信息隐藏等原则, 设计关联尽可能小的类.
    * 可扩展. 增加系统的功能, 无须破坏底层结构.
    * 可重用性
    * 高扇入  有着很好的低层次的工具类.
    * 低扇出  一个类, 尽可能少的使用其他类.
    * 层次性  尽量保持各个分解层的层次性.
            比如, 一个旧项目, 在新系统中, 可以编写一个层, 专门负责交互. 这样, 1. 把原来低质量的代码封起来 2. 如果能够抛弃原来的代码, 比如重构, 仅仅是需要删除修改交互层的代码.

### 设计的层次

#### 软件系统

#### 子程序或者包

把程序分为几个主要的子系统, 并且清楚地允许, 各个子系统之间如何使用. 各个子系统的内部, 可能使用不同的设计方法.
这个时候, 有一点特别重要, 不同的子系统之间, 相互通信的规则. 如果, 所有的子系统都能和其他子系统通信, 就完全失去了分开的好处了. 应该限制通让每个子系统有存在意义.
把子系统之间的连线当做水管, 当想要去掉某个子系统的时候, 势必有水管在上面, 你要断开又连接的水管数量越多, 就越麻烦. 所以, 只有确定了解, 才让子系统之间有通信. 简化各个子系统之间的交互关系. 最简单的就是调用, 复杂一点是一个子系统, 包含另一个子系统的类, 然后就是一个子系统, 继承自别的系统的类. 
一个很好的原则就是, 系统的设计是无环的, 就是程序中不应该有环形的关系. A使用了b, b使用了c, c又用到a.

常用的子系统
* 业务规则 -- 比如税务软件, 税务计算的方法
* 用户界面
* 数据库
* 操作系统的依赖. 把对操作系统的依赖封装, 在移植的时候, 修改这一层就可以了.

#### 分解为类.
    
    数据库子系统, 进一步被分成了数据访问类, 持久化框架类, 数据库管理类. 定义类的时候, 也就定义了这些类和系统的其他部分打交道的细节. 尤其是确定类的接口, 总的来说, 这一层主要任务是, 把所有的子系统做分解, 确保分解的细节, 是单个类能实现的.

#### 分解子程序.

    第三层, 定义类的接口, 现在具体细化实现细节. 

#### 编写子程序

    具体编码

## 启发式方法.

1. 形成一致的抽象. 抽象是一种能够让你在关注某一个概念的同时, 可以放心的忽略其中的细节的能力. 在不同的层次, 处理不同的细节. 
    基类, 也是一种抽象, 使得你可以集中精力关注共有的特性, 忽略派生类的细节.
    好的接口, 也是一种抽象, 让你关注接口本身而不是类的内部工作方式. 一个良好设计的子程序的接口, 在低层次完成抽象, 而子系统, 则是在高层次.
    从复杂度的角度来看, 抽象主要就是忽略无关的细节. 如果程序员, 不能用高层的抽象编编程, 系统就会很复杂.

 1. 封装实现细节.

    抽象, 从高层的细节看待一个对象, 封装, 除了暴露的接口, 你看不到任何对象的其他细节. 这就是信息隐藏.   