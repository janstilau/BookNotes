# workflow总结

## 工作方式问题

1. 没有搞明白整体的架构就开始设计分配给自己的部分, 其实根本不知道自己写的具体的功能代码怎么填充到整体架构中, 这样写出来的东西在真正填充的时候, 其实是面临着大面积的修改工作.
1. 没有抓准重点工作. 有好几天是为了数据存储位置的问题纠结, 主要问题在于, 将数据存储放在schemaManager里面, 用现有的代码没有办法实现内存管理的问题.
1. 为了很多不必要的东西过渡设计. 现在关于计算属性, 在设计shema的时候增加了很多计算表达式, 然后代码里面还要分析, 目前的需要这种模式的也就mapid, regionId, 还有营地的中心点提前的三种情况. 现在这些东西统一写在了一起, 用一个很特殊的函数处理. 但是需要计算的地方其实现在还只有三种, 根本就没有必要写一个通用的处理过程.
1. 提早交流配合, 要知道对方的代码应该怎么使用, 对于重要的部分, 比如workflow不但要知道接口, 也应该知道里面的实现细节. 因为自己写的东西统一要交到这个类来管理, 而这个类又十分重要, 知道怎么实现细节对自己调试的寻找问题也很有帮助. 提早交流配合也暴露很多问题, 这些问题是只设计自己部分的代码的时候还是想不到的.

## 代码问题

1. 数据存储工作还是在各个manager里面, 因为统一放在schemaManager里面其实要面临proeprtyBrower, 各个command, 各个tool的统一修改, 而这些工作和当前要实现workflow的工作关系不太大.
1. 现在用配置文件的这种方式, 在编写代码的时候, 根据属性名操作总觉得有安全隐患. 在编写填充task的时候, 经常出现要对某个特有属性进行取值赋值的操作, 比如城区的belongId其实是需要城市的coordId数据的, 这是时候就写成了cityobject.attribute("coordid"); 其实之前的代码也是这样写的, 不过coordid被枚举化了, 这样写的时候, 有这IDE的检查, 但是现在用字符串的形式, 相当于完全靠写代码的人检查了. 如果配置文件那里修改了, 其实这里也就全错了. 现在想到的也即是在取值赋值的过程中发现不是配置文件里面的值就直接报错, 不过这也得在执行的过程中才能发现. 不能做到编译的时候就报错.
1. 有些代码位置还是错误的. addArea, removeArea, 还有增加regionID, mapId这些代码还是放在schemaManager里面, 但是应该放到各个task里面, 当时写在schemaManager里面是因为还没有task这个东西, 到写的时候, 就变成简单的调用了. 而且这个东西还是个单例, 调用的时候就很方便, 所以没有注意.

## 业务流问题

1. dialogShow这种方式没有办法用, 因为workflow管理这整个task的生命周期. 而workflow的run方式, 是一个循环. 当中间没有exec这种方式, 让这个循环保持住的话, 这个循环立马退出, 然后workflow析构, 删除所有的task, 那么timerout的时候, 就会崩溃了. 之前的代码, 模拟城市生成, 这个task的执行所在类, 是作为dialog的成员变量存在的. 而现在是workflow管理的.
1. task其实被我们当做函数来调用的. input和para这些配置, 可以看做函数的参数配置, 而step, time可以看做是函数的运行配置. 而函数在ide里面调用的时候, 是有类型校验和个数校验的. 现在这种校验完全放在run里面, 在我们封装了成为函数调用的时候, 有一半的代码是在做校验. 可以增加task的原型信息, 这些信息存储参数的个数类型, 然后在基类里面写run, run{checkInput(); businessRun(); runcheckOutput();}. 在checkInput的时候, 还应该进行param里面的校验, 这个工作是交给每个子类完成的. 现在的参数解析工作, 也是没有统一规定的. 如果添加了规定, 首先在parseParameter的时候, 就能提示错误, 在checkParameter的时候, 去检查各个子类定义的成员变量的值的信息.

## 收获

1. 不要推卸责任, 该弄明白的问题一定要提早弄明白, 不能因为没有分配给自己就放到后面, 尤其是那还是整个工作的交汇点.
1. 提早交流, 这样能暴露更多的问题.
1. 提早测试, 因为这两天很多问题是测试的时候暴露出来的. 比如原来的代码输出其实是由顺序的, 最特殊的就是城市输出其实是按照regionId, 和type 输出的, 没有做比较的话就会想当然的认为是按照x, y的方式. 这个测试的时候才能很明显的看出来. 还有就是生成outputmessage那个task, 原来设计是传入datatable然后根据datable生成x个这样的字符串, 但是这样很不合理, datatable为什么生成xx个呢. 后来就把filter, addAread这些task做了重写设计, 输出增加了处理前, 处理时增加或者删除的个数, 和最终个数三个输出, 都是int, outputmessage根据int替换%1
1. 抽象层的加深理解. 抽象的意义, 抽象的代价.

## Conference

1. 抓住全局概念. ---> 最重点的工作, 知道了全局才能知道自己的类怎么设计. 不要先做最简单的, 最后才去想那些难点. 例如dialog的问题, 如果一开始就开始设计这些, 也就不会再最后才发现有这么大的问题.
1. 沟通才能发现问题, 发现设计不一致, 其实就是问题, 两个人对于同一个问题的理解不一样, 很有可能对于问题的理解就有问题, 深入思考, 判断到底是哪里有疏漏.
1. 异常情况, 一定要提早的判断. 在一个switch里面, 5,6个case里面, 只有一个是正常run的, 如果说只处理了一个case, 那么其实只完成了一个case而已, 任务完成了也就只有20%或者10+%.
1. 测试的意义. 测试用例多, 测的全, 能够帮助你写出安全的代码. 或者 在编写代码的时候, 就要努力写出安全的代码.
1. 不正常的工作状态, 就是把工作都转移到了最后才完成. 应该用上面提出的各个点, 将工作合理的安排到每个时间段.

## 智能指针

应该了解在c++中智能指针的用法, 这个会经常被用到.

## workflow的数据配置

1. 统一用keyValue的形式, 就算是只有一个参数的配置, 也应该用keyValue的形式, 这样可以保证统一. 在input和output的时候, 也应该用keyvalue的形式进行配置.

## 后台服务

可以在后台, 用一个定时器每隔多少时间就进行一次检测, 检测当前的工程里面, 哪些特定的字段没有定义, 哪些特定的值配置错误. 例如, 在三国2里面, 是需要地图都是压缩格式的, 在检查到当前的地图不是这个格式之后, 可以做一个导航功能, 导航到配置这个字段应该在的位置, 或者添加一个问号浮现的图标, 在点击这个图标之后, 打开对应的帮助文档.
